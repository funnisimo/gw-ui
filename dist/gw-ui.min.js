!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],s):s((t="undefined"!=typeof globalThis?globalThis:t||self).GWI={},t.GWU,t.GWM)}(this,(function(t,s,e){"use strict";function i(t){if(t&&t.__esModule)return t;var s=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var i=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(s,e,i.get?i:{enumerable:!0,get:function(){return t[e]}})}})),s.default=t,Object.freeze(s)}var h=i(s),o=i(e);const r=h.color.install("flavorText",50,40,90),n=h.color.install("flavorPrompt",100,90,20);t.Flavor=class{constructor(t){this.text="",this.needsUpdate=!1,this.isPrompt=!1,this.overflow=!1,this.ui=t.ui,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,1)}setFlavorText(t){this.text=h.text.capitalize(t),this.needsUpdate=!0,this.isPrompt=!1,this.draw()}clear(){this.text="",this.needsUpdate=!0,this.isPrompt=!1,this.draw()}showPrompt(t){this.text=h.text.capitalize(t),this.needsUpdate=!0,this.isPrompt=!0,this.draw()}draw(t=!1){if(!t&&!this.needsUpdate)return!1;const s=this.ui.buffer,e=this.isPrompt?n:r,i=s.wrapText(this.bounds.x,this.bounds.y,this.bounds.width,this.text,e,h.colors.black);return this.overflow=i!==this.bounds.y+1,this.ui.render(),this.needsUpdate=!1,!0}getFlavorText(t,s,e){const i=t.cell(s,e);let r,n="";const f=i.actor||null,a=(null==f?void 0:f.isPlayer())?f:null,l=i.item,u=i.hasTileFlag(o.flags.Tile.T_STAND_IN_TILE);if(a&&s==a.x&&e==a.y)return r=a.hasStatus("levitating")?h.text.apply("you are hovering above §flavor§.",{actor:a,flavor:i.getFlavor()}):h.text.apply("you see yourself.",{actor:f}),r;if(!t.fov.isAnyKindOfVisible(s,e)){if(r="",t.fov.isRevealed(s,e)){const i=t.cellInfo(s,e,!0);n=i.item?i.item.getName({color:!1,article:!0}):i.actor?i.actor.getName({color:!1,article:!0}):i.tile.getFlavor(),r=h.text.apply("you remember seeing §object§ here.",{actor:f,object:n})}else if(t.fov.isMagicMapped(s,e)){const i=t.cellInfo(s,e,!0);r=h.text.apply("you expect §text§ to be here.",{actor:f,text:i.tile.getFlavor()})}return r}let c=!1;f?(n=f.getName({color:!1,article:!0})+" standing",c=!0):l&&(n=l.getName({color:!1,article:!0}),c=!0);let d=u?" in ":" on ";const b=i.depthTile(o.flags.Depth.GROUND)||o.tile.tiles.NULL,g=i.depthTile(o.flags.Depth.SURFACE),p=i.depthTile(o.flags.Depth.LIQUID);let w="";if(g){c&&(c=!1,n+=" on "),g.hasTileFlag(o.flags.Tile.T_BRIDGE)&&(d=" over "),w=g.getFlavor()+d}let x="";p&&(x=p.getFlavor()+" covering ",c&&(c=!1,n+=" in ")),c&&(c=!1,n+=" on ");let y=b.getFlavor({article:!0});return r=h.text.apply("you §action§ §text§.",{actor:f,action:t.isVisible(s,e)?"see":"sense",text:n+w+x+y}),r}},t.Messages=class{constructor(t){const s=t.ui.buffer;this.bounds=new h.xy.Bounds(t.x,t.y,Math.min(t.width||s.width,s.width-t.x),Math.min(t.height||s.height,s.height-t.y)),this.cache=new h.message.MessageCache({width:this.bounds.width,length:s.height}),this.ui=t.ui,this.bg=h.color.from(t.bg||"black"),this.fg=h.color.from(t.fg||"white")}contains(t,s){return this.bounds.contains(t,s)}get needsUpdate(){return this.cache.needsUpdate}get buffer(){return this.ui.buffer}draw(t=!1){if(!t&&!this.cache.needsUpdate)return!1;let s;const e=h.color.make(),i=this.bounds.y<10;return this.buffer.fillRect(this.bounds.x,this.bounds.y,this.bounds.width,this.bounds.height," ",0,this.bg),this.cache.forEach(((t,o,r)=>{if(r>=this.bounds.height)return;s=e,s.copy(this.fg),o&&(s.mix(this.bg,50),s.mix(this.bg,75*r/(2*this.bounds.height)));const n=i?this.bounds.height-r-1:r,f=this.toBufferY(n);h.text.eachChar(t,((t,i,h,n)=>{const a=this.toBufferX(n);i&&s!==i&&o&&(i.mix(this.bg,50),i.mix(this.bg,75*r/(2*this.bounds.height))),s=i||e,this.buffer.draw(a,f,t,s,this.bg)}))})),this.cache.needsUpdate=!1,!0}toBufferY(t){return this.bounds.y+t}toBufferX(t){return this.bounds.x+t}async showArchive(){let t,s,e,i=0,h=0;if(this.cache.forEach((()=>++h)),h<=this.bounds.height)return;const o=this.bounds.y<10,r=this.ui.startDialog();for(t=0;t<=1;t++){for(e=!1,i=t?h:this.bounds.height;t?i>=this.bounds.height:i<=h;i+=t?-1:1)this.ui.resetDialogBuffer(r),this.cache.forEach(((t,e,h)=>{if(h>=i||h>=r.height)return;const n=o?h:r.height-h-1;s=Math.floor(50*(i-h)/i);const f=this.fg.clone().mix(this.bg,s);r.wrapText(this.toBufferX(0),n,this.bounds.width,t,f,this.bg)})),r.render(),!e&&await this.ui.loop.pause(t?15:45)&&(e=!0,i=t?this.bounds.height+1:h-1);if(!t){const t=o?0:r.height-1,s=this.bounds.x>8?this.bounds.x-8:Math.min(this.bounds.x+this.bounds.width,this.buffer.width-8);r.wrapText(s,t,8,"--DONE--",this.bg,this.fg),r.render(),await this.ui.loop.waitForAck()}}this.ui.finishDialog(),this.cache.confirmAll(),this.cache.needsUpdate=!0}},t.UI=class{constructor(t={}){if(this.layers=[],this.freeBuffers=[],this.inDialog=!1,!t.canvas)throw new Error("Need a canvas.");this.canvas=t.canvas,this.buffer=t.canvas.buffer,this.loop=t.loop||h.loop}render(){this.buffer.render()}startDialog(){this.inDialog=!0;const t=this.buffer||this.canvas.buffer;return this.layers.push(t),this.buffer=this.freeBuffers.pop()||new h.canvas.Buffer(this.canvas),this.buffer.copy(t),this.buffer}resetDialogBuffer(t){const s=this.layers[this.layers.length-1]||this.canvas.buffer;t.copy(s)}finishDialog(){this.inDialog&&(this.buffer!==this.canvas.buffer&&this.freeBuffers.push(this.buffer),this.buffer=this.layers.pop()||this.canvas.buffer,this.buffer.render(),this.inDialog=this.layers.length>0)}},t.Viewport=class{constructor(t){this.follow=!1,this.snap=!1,this.filter=null,this.offsetX=0,this.offsetY=0,this.lockX=!1,this.lockY=!1,this.ui=t.ui,this.follow=t.follow||!1,this.snap=t.snap||!1,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,t.height),this.filter=t.filter||null,t.lock?(this.lockX=!0,this.lockY=!0):(t.lockX&&(this.lockX=!0),t.lockY&&(this.lockY=!0))}toMapX(t){return t+this.offsetX-this.bounds.x}toMapY(t){return t+this.offsetY-this.bounds.y}toInnerX(t){return t-this.bounds.x}toInnerY(t){return t-this.bounds.y}contains(t,s){return this.bounds.contains(t,s)}halfWidth(){return Math.floor(this.bounds.width/2)}halfHeight(){return Math.floor(this.bounds.height/2)}draw(t,s,e){if(!t)return!1;if(this.follow&&void 0!==s&&void 0!==e)this.offsetX=s-this.halfWidth(),this.offsetY=e-this.halfHeight();else if(this.snap&&void 0!==s&&void 0!==e){const i=this.offsetX,h=this.offsetX+this.bounds.width,o=this.offsetY,r=this.offsetY+this.bounds.height,n=Math.floor(this.bounds.width/5),f=Math.floor(this.bounds.height/5),a=Math.floor(this.bounds.width/3);i+n>=s?this.offsetX=Math.max(0,s+a-this.bounds.width):h-n<=s&&(this.offsetX=Math.min(s-a,t.width-this.bounds.width));const l=Math.floor(this.bounds.height/3);o+f>=e?this.offsetY=Math.max(0,e+l-this.bounds.height):r-f<=e&&(this.offsetY=Math.min(e-l,t.height-this.bounds.height))}else void 0!==s&&void 0!==e&&(this.offsetX=s,this.offsetY=e);this.lockX&&(this.offsetX=h.clamp(this.offsetX,0,t.width-this.bounds.width)),this.lockY&&(this.offsetY=h.clamp(this.offsetY,0,t.height-this.bounds.height));const i=new h.sprite.Mixer;for(let s=0;s<this.bounds.width;++s)for(let e=0;e<this.bounds.height;++e){const h=s+this.offsetX,o=e+this.offsetY;t.hasXY(h,o)?t.getAppearanceAt(h,o,i):i.blackOut(),this.filter&&this.filter(i,h,o,t),this.ui.buffer.drawSprite(s+this.bounds.x,e+this.bounds.y,i)}return!0}},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-ui.min.js.map
