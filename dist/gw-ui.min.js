!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],s):s((t="undefined"!=typeof globalThis?globalThis:t||self).GWI={},t.GWU,t.GWM)}(this,(function(t,s,i){"use strict";function e(t){if(t&&t.__esModule)return t;var s=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var e=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(s,i,e.get?e:{enumerable:!0,get:function(){return t[i]}})}})),s.default=t,Object.freeze(s)}var h=e(s),o=e(i);h.color.install("flavorText",50,40,90),h.color.install("flavorPrompt",100,90,20);t.Flavor=class{constructor(t){var s,i,e;this.text="",this.needsUpdate=!1,this.isPrompt=!1,this.overflow=!1,this.ui=t.ui,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,1),this.fg=h.color.from(null!==(s=t.fg)&&void 0!==s?s:"flavorText"),this.bg=h.color.from(null!==(i=t.bg)&&void 0!==i?i:"black"),this.promptFg=h.color.from(null!==(e=t.promptFg)&&void 0!==e?e:"flavorPrompt")}setFlavorText(t){this.text=h.text.capitalize(t),this.needsUpdate=!0,this.isPrompt=!1,this.draw()}clear(){this.text="",this.needsUpdate=!0,this.isPrompt=!1,this.draw()}showPrompt(t){this.text=h.text.capitalize(t),this.needsUpdate=!0,this.isPrompt=!0,this.draw()}draw(t=!1){if(!t&&!this.needsUpdate)return!1;const s=this.ui.buffer,i=this.isPrompt?this.fg:this.promptFg,e=s.wrapText(this.bounds.x,this.bounds.y,this.bounds.width,this.text,i,this.bg);return this.overflow=e!==this.bounds.y+1,this.ui.render(),this.needsUpdate=!1,!0}getFlavorText(t,s,i){const e=t.cell(s,i);let r,n="";const f=e.actor||null,a=(null==f?void 0:f.isPlayer())?f:null,l=e.item,u=e.hasTileFlag(o.flags.Tile.T_STAND_IN_TILE);if(a&&s==a.x&&i==a.y)return r=a.hasStatus("levitating")?h.text.apply("you are hovering above §flavor§.",{actor:a,flavor:e.getFlavor()}):h.text.apply("you see yourself.",{actor:f}),r;if(!t.fov.isAnyKindOfVisible(s,i)){if(r="",t.fov.isRevealed(s,i)){const e=t.cellInfo(s,i,!0);n=e.item?e.item.getName({color:!1,article:!0}):e.actor?e.actor.getName({color:!1,article:!0}):e.tile.getFlavor(),r=h.text.apply("you remember seeing §object§ here.",{actor:f,object:n})}else if(t.fov.isMagicMapped(s,i)){const e=t.cellInfo(s,i,!0);r=h.text.apply("you expect §text§ to be here.",{actor:f,text:e.tile.getFlavor()})}return r}let c=!1;f?(n=f.getName({color:!1,article:!0})+" standing",c=!0):l&&(n=l.getName({color:!1,article:!0}),c=!0);let d=u?" in ":" on ";const b=e.depthTile(o.flags.Depth.GROUND)||o.tile.tiles.NULL,g=e.depthTile(o.flags.Depth.SURFACE),p=e.depthTile(o.flags.Depth.LIQUID);let w="";if(g){c&&(c=!1,n+=" on "),g.hasTileFlag(o.flags.Tile.T_BRIDGE)&&(d=" over "),w=g.getFlavor()+d}let v="";p&&(v=p.getFlavor()+" covering ",c&&(c=!1,n+=" in ")),c&&(c=!1,n+=" on ");let x=b.getFlavor({article:!0});return r=h.text.apply("you §action§ §text§.",{actor:f,action:t.isVisible(s,i)?"see":"sense",text:n+w+v+x}),r}},t.Messages=class{constructor(t){const s=t.ui.buffer;this.bounds=new h.xy.Bounds(t.x,t.y,Math.min(t.width||s.width,s.width-t.x),Math.min(t.height||s.height,s.height-t.y)),this.cache=new h.message.MessageCache({width:this.bounds.width,length:s.height}),this.ui=t.ui,this.bg=h.color.from(t.bg||"black"),this.fg=h.color.from(t.fg||"white")}contains(t,s){return this.bounds.contains(t,s)}get needsUpdate(){return this.cache.needsUpdate}get buffer(){return this.ui.buffer}draw(t=!1){if(!t&&!this.cache.needsUpdate)return!1;let s;const i=h.color.make(),e=this.bounds.y<10;return this.buffer.fillRect(this.bounds.x,this.bounds.y,this.bounds.width,this.bounds.height," ",0,this.bg),this.cache.forEach(((t,o,r)=>{if(r>=this.bounds.height)return;s=i,s.copy(this.fg),o&&(s.mix(this.bg,50),s.mix(this.bg,75*r/(2*this.bounds.height)));const n=e?this.bounds.height-r-1:r,f=this.toBufferY(n);h.text.eachChar(t,((t,e,h,n)=>{const a=this.toBufferX(n);e&&s!==e&&o&&(e.mix(this.bg,50),e.mix(this.bg,75*r/(2*this.bounds.height))),s=e||i,this.buffer.draw(a,f,t,s,this.bg)}))})),this.cache.needsUpdate=!1,!0}toBufferY(t){return this.bounds.y+t}toBufferX(t){return this.bounds.x+t}async showArchive(){let t,s,i,e=0,h=0;if(this.cache.forEach((()=>++h)),h<=this.bounds.height)return;const o=this.bounds.y<10,r=this.ui.startDialog();for(t=0;t<=1;t++){for(i=!1,e=t?h:this.bounds.height;t?e>=this.bounds.height:e<=h;e+=t?-1:1)this.ui.resetDialogBuffer(r),this.cache.forEach(((t,i,h)=>{if(h>=e||h>=r.height)return;const n=o?h:r.height-h-1;s=Math.floor(50*(e-h)/e);const f=this.fg.clone().mix(this.bg,s);r.wrapText(this.toBufferX(0),n,this.bounds.width,t,f,this.bg)})),r.render(),!i&&await this.ui.loop.pause(t?15:45)&&(i=!0,e=t?this.bounds.height+1:h-1);if(!t){const t=o?0:r.height-1,s=this.bounds.x>8?this.bounds.x-8:Math.min(this.bounds.x+this.bounds.width,this.buffer.width-8);r.wrapText(s,t,8,"--DONE--",this.bg,this.fg),r.render(),await this.ui.loop.waitForAck()}}this.ui.finishDialog(),this.cache.confirmAll(),this.cache.needsUpdate=!0}},t.UI=class{constructor(t={}){if(this.layers=[],this.freeBuffers=[],this.inDialog=!1,!t.canvas)throw new Error("Need a canvas.");this.canvas=t.canvas,this.buffer=t.canvas.buffer,this.loop=t.loop||h.loop}render(){this.buffer.render()}startDialog(){this.inDialog=!0;const t=this.buffer||this.canvas.buffer;return this.layers.push(t),this.buffer=this.freeBuffers.pop()||new h.canvas.Buffer(this.canvas),this.buffer.copy(t),this.buffer}resetDialogBuffer(t){const s=this.layers[this.layers.length-1]||this.canvas.buffer;t.copy(s)}finishDialog(){this.inDialog&&(this.buffer!==this.canvas.buffer&&this.freeBuffers.push(this.buffer),this.buffer=this.layers.pop()||this.canvas.buffer,this.buffer.render(),this.inDialog=this.layers.length>0)}},t.Viewport=class{constructor(t){this.follow=!1,this.snap=!1,this.filter=null,this.offsetX=0,this.offsetY=0,this.lockX=!1,this.lockY=!1,this.ui=t.ui,this.follow=t.follow||!1,this.snap=t.snap||!1,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,t.height),this.filter=t.filter||null,t.lock?(this.lockX=!0,this.lockY=!0):(t.lockX&&(this.lockX=!0),t.lockY&&(this.lockY=!0))}toMapX(t){return t+this.offsetX-this.bounds.x}toMapY(t){return t+this.offsetY-this.bounds.y}toInnerX(t){return t-this.bounds.x}toInnerY(t){return t-this.bounds.y}contains(t,s){return this.bounds.contains(t,s)}halfWidth(){return Math.floor(this.bounds.width/2)}halfHeight(){return Math.floor(this.bounds.height/2)}draw(t,s,i){if(!t)return!1;if(this.follow&&void 0!==s&&void 0!==i)this.offsetX=s-this.halfWidth(),this.offsetY=i-this.halfHeight();else if(this.snap&&void 0!==s&&void 0!==i){const e=this.offsetX,h=this.offsetX+this.bounds.width,o=this.offsetY,r=this.offsetY+this.bounds.height,n=Math.floor(this.bounds.width/5),f=Math.floor(this.bounds.height/5),a=Math.floor(this.bounds.width/3);e+n>=s?this.offsetX=Math.max(0,s+a-this.bounds.width):h-n<=s&&(this.offsetX=Math.min(s-a,t.width-this.bounds.width));const l=Math.floor(this.bounds.height/3);o+f>=i?this.offsetY=Math.max(0,i+l-this.bounds.height):r-f<=i&&(this.offsetY=Math.min(i-l,t.height-this.bounds.height))}else void 0!==s&&void 0!==i&&(this.offsetX=s,this.offsetY=i);this.lockX&&(this.offsetX=h.clamp(this.offsetX,0,t.width-this.bounds.width)),this.lockY&&(this.offsetY=h.clamp(this.offsetY,0,t.height-this.bounds.height));const e=new h.sprite.Mixer;for(let s=0;s<this.bounds.width;++s)for(let i=0;i<this.bounds.height;++i){const h=s+this.offsetX,o=i+this.offsetY;t.hasXY(h,o)?t.getAppearanceAt(h,o,e):e.blackOut(),this.filter&&this.filter(e,h,o,t),this.ui.buffer.drawSprite(s+this.bounds.x,i+this.bounds.y,e)}return!0}},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-ui.min.js.map
