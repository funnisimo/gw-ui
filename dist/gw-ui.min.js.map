{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.fg = GWU.color.from((_a = opts.fg) !== null && _a !== void 0 ? _a : 'flavorText');\n        this.bg = GWU.color.from((_b = opts.bg) !== null && _b !== void 0 ? _b : 'black');\n        this.promptFg = GWU.color.from((_c = opts.promptFg) !== null && _c !== void 0 ? _c : 'flavorPrompt');\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? this.fg : this.promptFg;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, this.bg);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y) {\n        const cell = map.cellInfo(x, y, true);\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = map.fov.isAnyKindOfVisible(x, y);\n        const isDirectlyVisible = map.fov.isDirectlyVisible(x, y) ||\n            (!map.fov.isEnabled && isAnyKindOfVisible);\n        const isRemembered = map.fov.isRevealed(x, y);\n        const isMapped = map.fov.isMagicMapped(x, y);\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.actor || null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.item;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.follow = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this.ui = opts.ui;\n        this.follow = opts.follow || false;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    draw(map, playerX, playerY) {\n        if (!map)\n            return false;\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        if (this.follow && playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX - this.halfWidth();\n            this.offsetY = playerY - this.halfHeight();\n        }\n        else if (this.snap &&\n            playerX !== undefined &&\n            playerY !== undefined) {\n            const left = this.offsetX;\n            const right = this.offsetX + this.bounds.width;\n            const top = this.offsetY;\n            const bottom = this.offsetY + this.bounds.height;\n            const edgeX = Math.floor(this.bounds.width / 5);\n            const edgeY = Math.floor(this.bounds.height / 5);\n            const thirdW = Math.floor(this.bounds.width / 3);\n            if (left + edgeX >= playerX) {\n                this.offsetX = Math.max(0, playerX + thirdW - this.bounds.width);\n            }\n            else if (right - edgeX <= playerX) {\n                this.offsetX = Math.min(playerX - thirdW, map.width - this.bounds.width);\n            }\n            const thirdH = Math.floor(this.bounds.height / 3);\n            if (top + edgeY >= playerY) {\n                this.offsetY = Math.max(0, playerY + thirdH - this.bounds.height);\n            }\n            else if (bottom - edgeY <= playerY) {\n                this.offsetY = Math.min(playerY - thirdH, map.height - this.bounds.height);\n            }\n        }\n        else if (playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX;\n            this.offsetY = playerY;\n        }\n        if (this.lockX) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    map.getAppearanceAt(mapX, mapY, mixer);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["color","install","constructor","opts","_a","_b","_c","this","text","needsUpdate","isPrompt","overflow","ui","bounds","GWU","xy","Bounds","x","y","width","fg","from","bg","promptFg","showText","capitalize","draw","clear","showPrompt","force","buffer","nextY","wrapText","render","getFlavorText","map","cell","cellInfo","buf","object","isAnyKindOfVisible","fov","isDirectlyVisible","isEnabled","isRemembered","isRevealed","isMapped","isMagicMapped","intro","actor","theItem","item","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","Math","min","height","cache","message","MessageCache","length","contains","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","loop","pause","waitForAck","finishDialog","confirmAll","layers","freeBuffers","inDialog","canvas","Error","base","push","pop","Buffer","dest","follow","snap","filter","offsetX","offsetY","lockX","lockY","lock","toMapX","toMapY","toInnerX","toInnerY","halfWidth","halfHeight","playerX","playerY","undefined","left","right","top","bottom","edgeX","edgeY","thirdW","max","thirdH","clamp","mixer","sprite","Mixer","mapX","mapY","hasXY","getAppearanceAt","blackOut","drawSprite"],"mappings":"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"}