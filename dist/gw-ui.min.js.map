{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nconst flavorTextColor = GWU.color.install('flavorText', 50, 40, 90);\nconst flavorPromptColor = GWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n    }\n    setFlavorText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? flavorPromptColor : flavorTextColor;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, GWU.colors.black);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y) {\n        const cell = map.cell(x, y);\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const actor = cell.actor || null;\n        const player = (actor === null || actor === void 0 ? void 0 : actor.isPlayer()) ? actor : null;\n        const theItem = cell.item;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        if (player && x == player.x && y == player.y) {\n            if (player.hasStatus('levitating')) {\n                buf = GWU.text.apply('you are hovering above §flavor§.', {\n                    actor: player,\n                    flavor: cell.getFlavor(),\n                });\n            }\n            else {\n                // if (theItem) {\n                // \tbuf = ITEM.getFlavor(theItem);\n                // }\n                // else {\n                buf = GWU.text.apply('you see yourself.', { actor });\n                // }\n            }\n            return buf;\n        }\n        //\n        // // detecting magical items\n        // magicItem = null;\n        // if (theItem && !playerCanSeeOrSense(x, y)\n        // \t&& GW.item.isDetected(theItem))\n        // {\n        // \tmagicItem = theItem;\n        // } else if (monst && !playerCanSeeOrSense(x, y)\n        // \t\t   && monst.carriedItem\n        // \t\t   && GW.item.isDetected(monst.carriedItem))\n        // {\n        // \tmagicItem = monst.carriedItem;\n        // }\n        // if (magicItem) {\n        // \treturn GW.item.detectedText(magicItem);\n        // }\n        //\n        // // telepathy\n        // if (monst\n        //       && !(cell.flags & VISIBLE) \t\t\t\t\t // && !GW.player.canSeeMonster(monst)\n        // \t\t\t&& (cell.flags & TELEPATHIC_VISIBLE)) // GW.actor.telepathicallyRevealed(monst))\n        // {\n        // \treturn GW.actor.telepathyText(monst);\n        // }\n        //\n        // if (monst && !playerCanSeeOrSense(x, y)) {\n        //       // Monster is not visible.\n        // \tmonst = null;\n        // }\n        if (!map.fov.isAnyKindOfVisible(x, y)) {\n            buf = '';\n            if (map.fov.isRevealed(x, y)) {\n                // memory\n                const cellInfo = map.cellInfo(x, y, true);\n                if (cellInfo.item) {\n                    // if (player.status.hallucinating && !GW.GAME.playbackOmniscience) {\n                    //     object = GW.item.describeHallucinatedItem();\n                    // } else {\n                    object = cellInfo.item.getName({\n                        color: false,\n                        article: true,\n                    });\n                    // object = GW.item.describeItemBasedOnParameters(cell.rememberedItemCategory, cell.rememberedItemKind, cell.rememberedItemQuantity);\n                    // }\n                }\n                else if (cellInfo.actor) {\n                    object = cellInfo.actor.getName({\n                        color: false,\n                        article: true,\n                    });\n                }\n                else {\n                    object = cellInfo.tile.getFlavor();\n                }\n                buf = GWU.text.apply('you remember seeing §object§ here.', {\n                    actor,\n                    object,\n                });\n            }\n            else if (map.fov.isMagicMapped(x, y)) {\n                // magic mapped\n                const cellInfo = map.cellInfo(x, y, true);\n                buf = GWU.text.apply('you expect §text§ to be here.', {\n                    actor,\n                    text: cellInfo.tile.getFlavor(),\n                });\n            }\n            return buf;\n        }\n        let needObjectArticle = false;\n        if (actor) {\n            object =\n                actor.getName({ color: false, article: true }) + ' standing';\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getName({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('you §action§ §text§.', {\n            actor,\n            action: map.isVisible(x, y) ? 'see' : 'sense',\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.follow = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this.ui = opts.ui;\n        this.follow = opts.follow || false;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    draw(map, playerX, playerY) {\n        if (!map)\n            return false;\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        if (this.follow && playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX - this.halfWidth();\n            this.offsetY = playerY - this.halfHeight();\n        }\n        else if (this.snap &&\n            playerX !== undefined &&\n            playerY !== undefined) {\n            const left = this.offsetX;\n            const right = this.offsetX + this.bounds.width;\n            const top = this.offsetY;\n            const bottom = this.offsetY + this.bounds.height;\n            const edgeX = Math.floor(this.bounds.width / 5);\n            const edgeY = Math.floor(this.bounds.height / 5);\n            const thirdW = Math.floor(this.bounds.width / 3);\n            if (left + edgeX >= playerX) {\n                this.offsetX = Math.max(0, playerX + thirdW - this.bounds.width);\n            }\n            else if (right - edgeX <= playerX) {\n                this.offsetX = Math.min(playerX - thirdW, map.width - this.bounds.width);\n            }\n            const thirdH = Math.floor(this.bounds.height / 3);\n            if (top + edgeY >= playerY) {\n                this.offsetY = Math.max(0, playerY + thirdH - this.bounds.height);\n            }\n            else if (bottom - edgeY <= playerY) {\n                this.offsetY = Math.min(playerY - thirdH, map.height - this.bounds.height);\n            }\n        }\n        else if (playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX;\n            this.offsetY = playerY;\n        }\n        if (this.lockX) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    map.getAppearanceAt(mapX, mapY, mixer);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["flavorTextColor","GWU","color","install","flavorPromptColor","constructor","opts","this","text","needsUpdate","isPrompt","overflow","ui","bounds","xy","Bounds","x","y","width","setFlavorText","capitalize","draw","clear","showPrompt","force","buffer","nextY","wrapText","colors","black","render","getFlavorText","map","cell","buf","object","actor","player","isPlayer","theItem","item","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","hasStatus","apply","flavor","getFlavor","fov","isAnyKindOfVisible","isRevealed","cellInfo","getName","article","tile","isMagicMapped","needObjectArticle","groundTile","depthTile","Depth","GROUND","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","action","isVisible","Math","min","height","cache","message","MessageCache","length","bg","from","fg","contains","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","loop","pause","waitForAck","finishDialog","confirmAll","layers","freeBuffers","inDialog","canvas","Error","base","push","pop","Buffer","dest","follow","snap","filter","offsetX","offsetY","lockX","lockY","lock","toMapX","toMapY","toInnerX","toInnerY","halfWidth","halfHeight","playerX","playerY","undefined","left","right","top","bottom","edgeX","edgeY","thirdW","max","thirdH","clamp","mixer","sprite","Mixer","mapX","mapY","hasXY","getAppearanceAt","blackOut","drawSprite"],"mappings":"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"}