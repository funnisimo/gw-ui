{"version":3,"file":"gw-ui.min.js","sources":["../js/widget/widget.js","../js/widget/text.js","../js/widget/button.js","../js/widget/input.js","../js/widget/dialog.js","../js/flavor.js","../js/sidebar.js","../js/menu.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nexport class Widget {\n    constructor(id, opts) {\n        this.active = false;\n        this.hovered = false;\n        this.tabStop = false;\n        this.fg = 0xfff;\n        this.bg = -1;\n        this.activeFg = 0xfff;\n        this.activeBg = -1;\n        this.hoverFg = 0xfff;\n        this.hoverBg = -1;\n        this.text = '';\n        this.align = 'left';\n        this.valign = 'middle';\n        this.bounds = new GWU.xy.Bounds(0, 0, 0, 0);\n        this.id = id;\n        if (opts)\n            this.init(opts);\n        this.reset();\n    }\n    init(opts) {\n        if (opts.x !== undefined)\n            this.bounds.x = opts.x;\n        if (opts.y !== undefined)\n            this.bounds.y = opts.y;\n        if (opts.width !== undefined)\n            this.bounds.width = opts.width;\n        if (opts.height !== undefined)\n            this.bounds.height = opts.height;\n        if (opts.text) {\n            this.text = opts.text;\n            if (!this.bounds.width)\n                this.bounds.width = opts.text.length;\n            if (!this.bounds.height)\n                this.bounds.height = 1;\n        }\n        if (opts.fg !== undefined) {\n            this.fg = opts.fg;\n            this.activeFg = opts.fg;\n            this.hoverFg = opts.fg;\n        }\n        if (opts.bg !== undefined) {\n            this.bg = opts.bg;\n            this.activeBg = opts.bg;\n            this.hoverBg = opts.bg;\n        }\n        if (opts.activeFg !== undefined) {\n            this.activeFg = opts.activeFg;\n            this.hoverFg = opts.activeFg;\n        }\n        if (opts.activeBg !== undefined) {\n            this.activeBg = opts.activeBg;\n            this.hoverBg = opts.activeBg;\n        }\n        if (opts.hoverFg !== undefined)\n            this.hoverFg = opts.hoverFg;\n        if (opts.hoverBg !== undefined)\n            this.hoverBg = opts.hoverBg;\n        if (opts.tabStop !== undefined)\n            this.tabStop = opts.tabStop;\n        this.action = opts.action || this.id;\n    }\n    reset() { }\n    contains(x, y) {\n        if (arguments.length == 1)\n            return this.bounds.contains(x);\n        return this.bounds.contains(x, y);\n    }\n    // returns true if mouse is over this widget\n    mousemove(e, _ui) {\n        this.hovered = this.contains(e);\n        return this.hovered;\n    }\n    tick(_e, _ui) { }\n    // returns true if click is handled by this widget (stopPropagation)\n    click(_e, _ui) {\n        return false;\n    }\n    // returns true if key is used by widget and you want to stopPropagation\n    keypress(_e, _ui) {\n        return false;\n    }\n    draw(buffer) {\n        const fg = this.active\n            ? this.activeFg\n            : this.hovered\n                ? this.hoverFg\n                : this.fg;\n        const bg = this.active\n            ? this.activeBg\n            : this.hovered\n                ? this.hoverBg\n                : this.bg;\n        const textLen = GWU.text.length(this.text);\n        if (this.bounds.width > textLen || this.bounds.height > 1) {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', fg, bg);\n        }\n        let x = this.bounds.x;\n        if (this.align == 'center') {\n            x += Math.floor((this.bounds.width - textLen) / 2);\n        }\n        else if (this.align == 'right') {\n            x += this.bounds.width - textLen;\n        }\n        let y = this.bounds.y; // 'top'\n        if (this.bounds.height > 1) {\n            if (this.valign == 'middle') {\n                y += Math.floor(this.bounds.height / 2);\n            }\n            else if (this.valign == 'bottom') {\n                y += this.bounds.height - 1;\n            }\n        }\n        buffer.drawText(x, y, this.text, fg, bg);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Text extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        // if (!opts.text)\n        //     throw new Error(\n        //         'Must have text value in config for Text widget - ' + this.id\n        //     );\n        this.text = opts.text || '';\n        if (opts.wrap) {\n            opts.width = opts.wrap;\n            this.lines = GWU.text.splitIntoLines(this.text, \n            // @ts-ignore\n            opts.width);\n        }\n        else {\n            const textLen = GWU.text.length(this.text);\n            opts.width = opts.width || textLen || 10;\n            if (opts.width < textLen) {\n                opts.text = GWU.text.truncate(this.text, opts.width);\n            }\n            this.lines = [this.text];\n        }\n        opts.height = Math.max(this.lines.length, opts.height || 1);\n        super.init(opts);\n    }\n    // TODO - get text() {}, set text(v:string) { // do lines stuff }\n    draw(buffer) {\n        const fg = this.active ? this.activeFg : this.fg;\n        const bg = this.active ? this.activeBg : this.bg;\n        this.lines.forEach((line, i) => {\n            buffer.drawText(this.bounds.x, this.bounds.y + i, line, fg, bg, this.bounds.width);\n        });\n    }\n}\n","import * as Widget from './widget';\nexport class Button extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        var _a;\n        this.actionFn = null;\n        if (!opts.text)\n            throw new Error('Must have text value in config for Button widget - ' + this.id);\n        opts.tabStop = (_a = opts.tabStop) !== null && _a !== void 0 ? _a : true; // Can receive input (Enter)\n        super.init(opts);\n        if (opts.actionFn)\n            this.actionFn = opts.actionFn;\n    }\n    click(ev) {\n        if (!this.contains(ev))\n            return false;\n        let r;\n        if (this.actionFn) {\n            r = this.actionFn(ev, this);\n        }\n        else {\n            r = this.parent.fireAction(this.action, this);\n        }\n        if (r)\n            return r.then(() => true);\n        return true;\n    }\n    keypress(ev) {\n        if (!ev.key)\n            return false;\n        if (ev.key === 'Enter') {\n            const r = this.parent.fireAction(this.action, this);\n            if (r)\n                return r.then(() => true);\n            return true;\n        }\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Input extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        var _a, _b, _c;\n        this.minLength = opts.minLength || 1;\n        if (!opts.width) {\n            opts.width = Math.max(this.minLength, 10);\n        }\n        opts.tabStop = (_a = opts.tabStop) !== null && _a !== void 0 ? _a : true; // Need to receive input\n        super.init(opts);\n        this.default = opts.default || '';\n        this.errorFg = opts.errorFg || this.fg;\n        this.hint = opts.hint || '';\n        this.hintFg = opts.hintFg || this.errorFg;\n        this.numbersOnly = opts.numbersOnly || false;\n        this.min = (_b = opts.min) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n        this.max = (_c = opts.max) !== null && _c !== void 0 ? _c : Number.MAX_SAFE_INTEGER;\n        if (!this.bounds.width) {\n            if (this.hint)\n                this.bounds.width = this.hint.length;\n            if (this.default)\n                this.bounds.width = this.default.length;\n        }\n        if (!this.bounds.height) {\n            this.bounds.height = 1;\n        }\n        this.reset();\n    }\n    reset() {\n        this.text = this.default;\n    }\n    isValid() {\n        if (this.numbersOnly) {\n            const val = Number.parseInt(this.text);\n            if (this.min !== undefined && val < this.min)\n                return false;\n            if (this.max !== undefined && val > this.max)\n                return false;\n            return val > 0;\n        }\n        return this.text.length >= this.minLength;\n    }\n    get value() {\n        if (this.numbersOnly)\n            return Number.parseInt(this.text);\n        return this.text;\n    }\n    keypress(ev, _ui) {\n        const textEntryBounds = this.numbersOnly ? ['0', '9'] : [' ', '~'];\n        if (!ev.key)\n            return false;\n        if (ev.key === 'Enter' && this.isValid()) {\n            const r = this.parent.fireAction(this.action, this);\n            if (r)\n                return r.then(() => true);\n            return true;\n        }\n        if (ev.key == 'Delete' || ev.key == 'Backspace') {\n            if (this.text.length) {\n                this.text = GWU.text.spliceRaw(this.text, this.text.length - 1, 1);\n            }\n            return true;\n        }\n        else if (ev.key.length > 1) {\n            // ignore other special keys...\n            return false;\n        }\n        // eat/use all other keys\n        if (ev.key >= textEntryBounds[0] && ev.key <= textEntryBounds[1]) {\n            // allow only permitted input\n            if (this.text.length < this.bounds.width) {\n                this.text += ev.key;\n            }\n        }\n        return true;\n    }\n    draw(buffer) {\n        const x = this.bounds.x;\n        const y = this.bounds.y;\n        const fg = this.active\n            ? this.activeFg\n            : this.hovered\n                ? this.hoverFg\n                : this.fg;\n        const bg = this.active\n            ? this.activeBg\n            : this.hovered\n                ? this.hoverBg\n                : this.bg;\n        buffer.fillRect(x, y, this.bounds.width, 1, ' ', fg, bg);\n        if (!this.text.length && this.hint && this.hint.length) {\n            buffer.drawText(x, y, this.hint, this.hintFg);\n        }\n        else {\n            const color = this.isValid() ? fg : this.errorFg;\n            buffer.drawText(x, y, this.text, color);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Dialog {\n    constructor(ui, opts) {\n        this.title = '';\n        this.titleFg = 0xfff;\n        this.bg = 0x999;\n        this.borderBg = 0x999;\n        this.widgets = [];\n        this.actionHandlers = {};\n        this.keypressHandlers = {};\n        this.clickHandlers = {};\n        this._activeWidget = null;\n        this.result = null;\n        this.done = false;\n        this.timers = {};\n        this.needsRedraw = true;\n        this.ui = ui;\n        this.id = 'DIALOG';\n        this.bounds = new GWU.xy.Bounds(-1, -1, 0, 0);\n        if (opts)\n            this.init(opts);\n    }\n    init(opts) {\n        if (opts.id)\n            this.id = opts.id;\n        if (opts.x !== undefined)\n            this.bounds.x = opts.x;\n        if (opts.y !== undefined)\n            this.bounds.y = opts.y;\n        if (opts.height !== undefined)\n            this.bounds.height = opts.height;\n        if (opts.width !== undefined)\n            this.bounds.width = opts.width;\n        if (opts.title)\n            this.title = opts.title;\n        if (opts.titleFg)\n            this.titleFg = opts.titleFg;\n        if (opts.bg) {\n            this.bg = opts.bg;\n            this.borderBg = opts.bg;\n        }\n        if (opts.borderBg) {\n            this.borderBg = opts.borderBg;\n        }\n    }\n    get activeWidget() {\n        return this._activeWidget;\n    }\n    set activeWidget(w) {\n        if (this._activeWidget) {\n            this._activeWidget.active = false;\n        }\n        this._activeWidget = w;\n        if (this._activeWidget) {\n            this._activeWidget.active = true;\n        }\n    }\n    contains(e) {\n        return this.bounds.contains(e);\n    }\n    requestRedraw() {\n        this.needsRedraw = true;\n    }\n    setTimeout(action, time) {\n        this.timers[action] = time;\n    }\n    clearTimeout(action) {\n        delete this.timers[action];\n    }\n    fireAction(action, widget) {\n        const handler = this.actionHandlers[action];\n        if (handler) {\n            return handler(action, widget, this);\n        }\n    }\n    setActionHandlers(map) {\n        this.actionHandlers = map;\n    }\n    setKeyHandlers(map) {\n        this.keypressHandlers = map;\n    }\n    setClickHandlers(map) {\n        this.clickHandlers = map;\n    }\n    async show() {\n        this.done = false;\n        // reset any temp data...\n        this.widgets.forEach((w) => w.reset());\n        // first tabStop is the starting active Widget\n        this.activeWidget = this.widgets.find((w) => w.tabStop) || null;\n        // start dialog\n        const buffer = this.ui.startLayer();\n        // run input loop\n        await this.ui.loop.run({\n            keypress: this.keypress.bind(this),\n            mousemove: this.mousemove.bind(this),\n            click: this.click.bind(this),\n            tick: this.tick.bind(this),\n            draw: () => {\n                this.draw(buffer);\n                buffer.render();\n            },\n        }, 100);\n        // stop dialog\n        this.ui.finishLayer();\n        return this.result;\n    }\n    close(returnValue) {\n        this.result = returnValue;\n        this.done = true;\n    }\n    widgetAt(x, y) {\n        return this.widgets.find((w) => w.contains(x, y)) || null;\n    }\n    getWidget(id) {\n        return this.widgets.find((w) => w.id === id) || null;\n    }\n    nextTabstop() {\n        if (!this.activeWidget) {\n            this.activeWidget = this.widgets.find((w) => w.tabStop) || null;\n            return !!this.activeWidget;\n        }\n        const next = GWU.arrayNext(this.widgets, this.activeWidget, (w) => w.tabStop);\n        if (next) {\n            this.activeWidget = next;\n            return true;\n        }\n        return false;\n    }\n    prevTabstop() {\n        if (!this.activeWidget) {\n            this.activeWidget = this.widgets.find((w) => w.tabStop) || null;\n            return !!this.activeWidget;\n        }\n        const prev = GWU.arrayPrev(this.widgets, this.activeWidget, (w) => w.tabStop);\n        if (prev) {\n            this.activeWidget = prev;\n            return true;\n        }\n        return false;\n    }\n    tick(e) {\n        const dt = e.dt;\n        let promises = [];\n        Object.entries(this.timers).forEach(([action, time]) => {\n            time -= dt;\n            if (time <= 0) {\n                delete this.timers[action];\n                const r = this.fireAction(action, null);\n                if (r && r.then) {\n                    promises.push(r);\n                }\n            }\n            else {\n                this.timers[action] = time;\n            }\n        });\n        for (let w of this.widgets) {\n            const r = w.tick(e, this.ui);\n            if (r && r.then) {\n                promises.push(r);\n            }\n        }\n        if (promises.length) {\n            return Promise.all(promises).then(() => this.done);\n        }\n        return this.done;\n    }\n    // TODO - async - to allow animations or events on mouseover?\n    mousemove(e) {\n        // this.activeWidget = null;\n        this.widgets.forEach((w) => {\n            w.mousemove(e, this.ui);\n            if (w.hovered && w.tabStop) {\n                this.activeWidget = w;\n            }\n        });\n        return this.done;\n    }\n    click(e) {\n        this.mousemove(e); // make sure activeWidget is set correctly\n        let fn = null;\n        if (this.activeWidget) {\n            fn = this.clickHandlers[this.activeWidget.id];\n        }\n        if (!fn && this.contains(e)) {\n            fn = this.clickHandlers[this.id];\n        }\n        if (!fn) {\n            fn = this.clickHandlers.click;\n        }\n        if (fn) {\n            const r = fn(e, this.activeWidget, this);\n            if (r && r.then) {\n                return r.then(() => this.done);\n            }\n        }\n        else if (this.activeWidget) {\n            const r = this.activeWidget.click(e, this.ui);\n            if (typeof r !== 'boolean') {\n                return r.then(() => this.done);\n            }\n        }\n        return this.done;\n    }\n    keypress(e) {\n        if (!e.key)\n            return false;\n        const fn = this.keypressHandlers[e.key] ||\n            (e.code && this.keypressHandlers[e.code]) ||\n            this.keypressHandlers.keypress;\n        if (fn) {\n            const r = fn(e, this.activeWidget, this);\n            if (r && r.then) {\n                return r.then(() => this.done);\n            }\n            return this.done;\n        }\n        if (this.activeWidget) {\n            const r = this.activeWidget.keypress(e, this.ui);\n            if (typeof r !== 'boolean') {\n                return r.then(() => this.done);\n            }\n            if (e.key === 'Tab') {\n                // Next widget\n                this.nextTabstop();\n            }\n            else if (e.key === 'TAB') {\n                // Prev Widget\n                this.prevTabstop();\n            }\n        }\n        return this.done;\n    }\n    draw(buffer, force = false) {\n        if (!this.needsRedraw && !force)\n            return;\n        // Draw dialog\n        if (this.borderBg) {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.borderBg, this.borderBg);\n            buffer.fillRect(this.bounds.x + 1, this.bounds.y + 1, this.bounds.width - 2, this.bounds.height - 2, ' ', this.bg, this.bg);\n        }\n        else {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        }\n        if (this.title) {\n            const x = this.bounds.x +\n                Math.floor((this.bounds.width - GWU.text.length(this.title)) / 2);\n            buffer.drawText(x, this.bounds.y, this.title, this.titleFg);\n        }\n        this.widgets.forEach((w) => w.draw(buffer));\n    }\n}\nexport class DialogBuilder {\n    constructor(ui, opts = {}) {\n        this.nextY = 0;\n        this.padY = 1;\n        this.padX = 1;\n        this.padX = opts.padX || opts.pad || 1;\n        this.padY = opts.padY || opts.pad || 1;\n        this.nextY = this.padY;\n        this.dialog = new Dialog(ui, opts);\n    }\n    with(widget) {\n        // widget bounds are set relative to the dialog top left,\n        // if we don't get any, help them out\n        let y = widget.bounds.y;\n        if (y >= 0 && y < this.padY) {\n            y = this.nextY;\n        }\n        else if (y < 0 && y > -this.padY) {\n            y = -this.padY;\n        }\n        widget.bounds.y = y;\n        let x = widget.bounds.x;\n        if (x >= 0 && x < this.padX) {\n            x = this.padX;\n        }\n        else if (x < 0 && x > -this.padX) {\n            x = -this.padX;\n        }\n        widget.bounds.x = x;\n        // TODO - Get rid of x, y\n        this.addWidget(widget);\n        this.nextY = Math.max(this.nextY, widget.bounds.bottom + 1 + this.padY);\n        return this;\n    }\n    center() {\n        const size = this.dialog.ui.buffer;\n        const bounds = this.dialog.bounds;\n        bounds.x = Math.floor((size.width - bounds.width) / 2);\n        bounds.y = Math.floor((size.height - bounds.height) / 2);\n        return this;\n    }\n    place(x, y) {\n        const bounds = this.dialog.bounds;\n        bounds.x = x;\n        bounds.y = y;\n        return this;\n    }\n    done() {\n        // lock in locations\n        this.dialog.widgets.forEach((w) => {\n            w.bounds.x += this.dialog.bounds.x;\n            w.bounds.y += this.dialog.bounds.y;\n        });\n        return this.dialog;\n    }\n    addWidget(widget) {\n        widget.parent = this.dialog;\n        const dlgBounds = this.dialog.bounds;\n        const x = widget.bounds.x;\n        const y = widget.bounds.y;\n        if (x >= 0) {\n            dlgBounds.width = Math.max(dlgBounds.width, widget.bounds.width + x + this.padX);\n        }\n        else {\n            widget.bounds.x = dlgBounds.width - widget.bounds.width + x;\n        }\n        if (y >= 0) {\n            dlgBounds.height = Math.max(dlgBounds.height, widget.bounds.height + y + this.padY);\n        }\n        else {\n            widget.bounds.y = dlgBounds.height - widget.bounds.height + y;\n        }\n        this.dialog.widgets.push(widget);\n        return widget;\n    }\n}\nexport function buildDialog(ui, opts = {}) {\n    return new DialogBuilder(ui, opts);\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as Widget from './widget';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor extends Widget.Text {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        opts.fg = opts.fg || 'flavorText';\n        opts.bg = opts.bg || 'black';\n        super.init(opts);\n        this.promptFg = GWU.color.from(opts.promptFg || 'flavorPrompt');\n        this.overflow = opts.overflow || false;\n        this.isPrompt = false;\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        const len = GWU.text.length(this.text);\n        if (len > this.bounds.width) {\n            this.lines = GWU.text.splitIntoLines(this.text, this.bounds.width);\n            if (!this.overflow && this.lines.length > this.bounds.height) {\n                if (this.bounds.height == 1) {\n                    this.text = GWU.text.truncate(this.text, this.bounds.width);\n                    this.lines = [this.text];\n                }\n                else {\n                    this.lines.length = this.bounds.height;\n                }\n            }\n        }\n        else {\n            this.lines = [this.text];\n        }\n        this.isPrompt = false;\n        if (this.parent)\n            this.parent.requestRedraw();\n    }\n    clear() {\n        this.text = '';\n        this.lines = [''];\n        this.isPrompt = false;\n        if (this.parent)\n            this.parent.requestRedraw();\n    }\n    showPrompt(text) {\n        this.showText(text);\n        this.isPrompt = true;\n    }\n    draw(buffer) {\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        super.draw(buffer);\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as Widget from './widget';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n        this.sidebarY = -1;\n    }\n    draw(_buffer, _bounds) {\n        return 0;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    draw(buffer, bounds) {\n        return this.actor.drawStatus(buffer, bounds);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    draw(buffer, bounds) {\n        return this.item.drawStatus(buffer, bounds);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(buffer, bounds) {\n        return this.cell.drawStatus(buffer, bounds);\n    }\n}\nexport class Sidebar extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.subject = null;\n        this.highlight = null;\n    }\n    init(opts) {\n        opts.fg = opts.fg || 'purple';\n        opts.bg = opts.bg || 'black';\n        super.init(opts);\n    }\n    reset() {\n        super.reset();\n        this.lastMap = null;\n        this.lastX = -1;\n        this.lastY = -1;\n    }\n    entryAt(e) {\n        return (this.entries.find((entry) => {\n            return entry.sidebarY <= e.y && entry.sidebarY !== -1;\n        }) || null);\n    }\n    mousemove(e, ui) {\n        super.mousemove(e, ui);\n        if (this.contains(e)) {\n            return this.highlightRow(e.y);\n        }\n        return this.clearHighlight();\n    }\n    highlightRow(y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        if (this.parent)\n            this.parent.requestRedraw();\n        return this.highlight !== last;\n    }\n    clearHighlight() {\n        const result = !!this.highlight;\n        this.highlight = null;\n        if (this.parent)\n            this.parent.requestRedraw();\n        return result;\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return entry.priority > 2 || !!this.highlight;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this._addItemEntry(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    update() {\n        if (!this.subject) {\n            throw new Error('Update requires a subject to follow.');\n        }\n        return this.updateFor(this.subject);\n    }\n    updateFor(subject) {\n        return this.updateAt(subject.memory || subject.map, subject.x, subject.y, subject.fov);\n    }\n    updateAt(map, cx, cy, fov) {\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        if (this.parent)\n            this.parent.requestRedraw();\n        return true;\n    }\n    draw(buffer) {\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        const drawBounds = this.bounds.clone();\n        let currentEntry;\n        for (let i = 0; i < this.entries.length && drawBounds.height > 0; ++i) {\n            currentEntry = this.entries[i];\n            currentEntry.sidebarY = drawBounds.y;\n            let usedLines = currentEntry.draw(buffer, drawBounds);\n            if (this._isDim(currentEntry)) {\n                buffer.mix(this.bg, 50, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            if (usedLines) {\n                ++usedLines; // skip a space\n                drawBounds.y += usedLines;\n                drawBounds.height -= usedLines;\n            }\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Button {\n    constructor(text) {\n        this.hovered = false;\n        this.x = 999;\n        this.text = text;\n    }\n    get width() {\n        return this.text.length;\n    }\n}\nexport class ActionButton extends Button {\n    constructor(text, fn) {\n        super(text);\n        this.fn = fn;\n    }\n    activate(e, ui) {\n        return this.fn(e, ui, this);\n    }\n}\nexport class DropDownButton extends Button {\n    constructor(menu, parent, text, buttons) {\n        super(text);\n        this.buttons = [];\n        this.parent = null;\n        this.menu = menu;\n        this.parent = parent;\n        this.text = text;\n        this.bounds = new GWU.xy.Bounds(0, 0, 0, 0);\n        Object.entries(buttons).forEach(([text, opts]) => {\n            this.addButton(text, opts);\n        });\n    }\n    addButton(text, config) {\n        // if (this.buttons.length >= this.menu.bounds.height - 1) {\n        //     throw new Error('Too many menu options.');\n        // }\n        let button;\n        if (typeof config === 'function') {\n            button = new ActionButton(text, config);\n        }\n        else if (typeof config === 'string') {\n            button = new ActionButton(text, () => {\n                const r = this.menu.parent.fireAction(config, this.menu);\n                if (r && r.then) {\n                    return r.then(() => true);\n                }\n                return true;\n            });\n        }\n        else {\n            button = new DropDownButton(this.menu, this, text, config);\n        }\n        this.buttons.push(button);\n        ++this.bounds.height;\n        this.bounds.width = Math.max(this.bounds.width, text.length + 2);\n    }\n    setBounds(buffer, px, py, pw) {\n        // vertical reveal\n        const right = px + pw;\n        const totalWidth = buffer.width;\n        if (this.bounds.width < totalWidth - right) {\n            this.bounds.x = right;\n        }\n        else if (this.bounds.width < px) {\n            this.bounds.x = px - this.bounds.width;\n        }\n        else {\n            throw new Error('Menu does not fit - too wide.');\n        }\n        const totalHeight = buffer.height;\n        if (this.bounds.height <= totalHeight - py) {\n            this.bounds.y = py;\n        }\n        else if (this.bounds.height < totalHeight) {\n            this.bounds.y = totalHeight - this.bounds.height - 1;\n        }\n        else {\n            throw new Error('Menu does not fit - too tall.');\n        }\n        // this.buttons.forEach((b) => {\n        //     if (b instanceof DropDownButton) {\n        //         b.setBounds(buffer);\n        //     }\n        // });\n    }\n    contains(e) {\n        return this.bounds.contains(e);\n    }\n    buttonAt(e) {\n        const index = e.y - this.bounds.y;\n        return this.buttons[index] || null;\n    }\n    draw(buffer) {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n        const x = this.bounds.x;\n        let y = this.bounds.y;\n        buffer.fillRect(x, y, width, height, 0, 0, this.menu.dropBg);\n        // Now draw the individual buttons...\n        this.buttons.forEach((b) => {\n            buffer.drawText(x + 1, y, b.text, b.hovered ? this.menu.activeFg : this.menu.dropFg, b.hovered ? this.menu.activeBg : this.menu.dropBg);\n            ++y;\n        });\n        if (this.parent) {\n            this.parent.draw(buffer);\n        }\n    }\n}\nexport async function showDropDown(menu, button, ui) {\n    // Start dialog\n    const dialog = ui.startLayer();\n    let activeButton = button;\n    await ui.loop.run({\n        Escape() {\n            return true;\n        },\n        mousemove: (e) => {\n            if (!activeButton)\n                return true; // we are done (should not happen)\n            let newActive = activeButton;\n            while (newActive && !newActive.contains(e)) {\n                newActive = newActive.parent;\n            }\n            if (newActive) {\n                activeButton = newActive;\n                const selected = activeButton.buttonAt(e);\n                if (selected) {\n                    activeButton.buttons.forEach((b) => {\n                        b.hovered = false;\n                    });\n                    selected.hovered = true;\n                    if (selected instanceof DropDownButton) {\n                        selected.buttons.forEach((b) => {\n                            b.hovered = false;\n                        });\n                        selected.setBounds(ui.buffer, activeButton.bounds.x, e.y, activeButton.bounds.width);\n                        activeButton = selected;\n                    }\n                }\n            }\n            else {\n                if (menu.contains(e)) {\n                    if (menu.parent)\n                        menu.parent.requestRedraw();\n                    const button = menu.getButtonAt(e.x, e.y);\n                    if (button instanceof DropDownButton) {\n                        activeButton.hovered = false;\n                        activeButton = button;\n                        activeButton.hovered = true;\n                    }\n                    else {\n                        activeButton = null; // done.\n                        if (button)\n                            button.hovered = true;\n                    }\n                }\n            }\n            return !activeButton; // if no active button we are done (should not happen)\n        },\n        click: async (e) => {\n            if (!activeButton)\n                return true; // we are done (should not happen)\n            if (!activeButton.contains(e)) {\n                menu.clearHighlight();\n                return true; // we are done\n            }\n            const actionButton = activeButton.buttonAt(e);\n            if (!actionButton) {\n                return true; // weird, but we are done.\n            }\n            if (actionButton instanceof ActionButton) {\n                return actionButton.activate(e, ui); // actions return true if they want to close the menu (otherwise the menu stays open)\n            }\n        },\n        draw: () => {\n            if (!activeButton)\n                return;\n            ui.resetLayerBuffer(dialog);\n            activeButton.draw(dialog);\n            menu.draw(dialog);\n            dialog.render();\n        },\n    });\n    ui.finishLayer();\n    menu.clearHighlight();\n}\nexport class Menu extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        var _a, _b;\n        opts.fg = (_a = opts.fg) !== null && _a !== void 0 ? _a : 'black';\n        opts.bg = (_b = opts.bg) !== null && _b !== void 0 ? _b : 'light_gray';\n        opts.height = opts.height || 1;\n        super.init(opts);\n        this.dropFg = GWU.color.from(opts.dropFg || this.fg);\n        this.dropBg = GWU.color.from(opts.dropBg || this.bg);\n        this.buttons = [];\n        this.separator = opts.separator || ' | ';\n        this.lead = opts.lead || ' ';\n        Object.entries(opts.buttons).forEach(([text, opts]) => {\n            this._addButton(text, opts);\n        });\n        if (opts.separator) {\n            this.separator = opts.separator;\n        }\n        if (opts.lead !== undefined) {\n            this.lead = opts.lead ? opts.lead : '';\n        }\n    }\n    mousemove(e) {\n        // turn off all the hovers\n        this.buttons.forEach((b) => {\n            if (b.hovered) {\n                b.hovered = false;\n            }\n        });\n        // highlight one of them...\n        if (this.bounds.contains(e)) {\n            let hovered = null;\n            this.buttons.forEach((b) => {\n                b.hovered = false;\n                if (b.x < e.x) {\n                    hovered = b;\n                }\n            });\n            if (hovered) {\n                // @ts-ignore\n                hovered.hovered = true;\n            }\n            if (this.parent)\n                this.parent.requestRedraw();\n            return true; // we handled the message\n        }\n        return false;\n    }\n    clearHighlight() {\n        this.buttons.forEach((b) => {\n            b.hovered = false;\n        });\n        if (this.parent)\n            this.parent.requestRedraw();\n    }\n    getButtonAt(x, _y) {\n        return GWU.arrayFindRight(this.buttons, (b) => b.x < x) || null;\n    }\n    async click(e, ui) {\n        if (this.bounds.contains(e)) {\n            // get active button\n            let activeButton = this.getButtonAt(e.x, e.y);\n            if (!activeButton)\n                return false;\n            if (activeButton instanceof DropDownButton) {\n                await showDropDown(this, activeButton, ui);\n            }\n            else if (activeButton instanceof ActionButton) {\n                await activeButton.activate(e, ui);\n            }\n            return true;\n        }\n        return false;\n    }\n    _addButton(text, config) {\n        const x = this.buttons.reduce((len, button) => len + button.text.length + this.separator.length, this.lead.length + this.bounds.x);\n        if (x + text.length + 2 > this.bounds.width) {\n            throw new Error('Button makes menu too wide :' + text);\n        }\n        let button;\n        if (typeof config === 'function') {\n            button = new ActionButton(text, config);\n        }\n        else {\n            const dropdown = new DropDownButton(this, null, text, config);\n            dropdown.bounds.x = x;\n            if (this.bounds.y) {\n                dropdown.bounds.y = this.bounds.y - dropdown.bounds.height;\n            }\n            else {\n                dropdown.bounds.y = this.bounds.y + 1;\n            }\n            button = dropdown;\n        }\n        button.x = x;\n        this.buttons.push(button);\n    }\n    draw(buffer) {\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, 1, 0, 0, this.bg);\n        let x = this.bounds.x;\n        const y = this.bounds.y;\n        buffer.drawText(x, y, this.lead, this.fg);\n        this.buttons.forEach((b) => {\n            const color = b.hovered ? this.activeFg : this.fg;\n            const bgColor = b.hovered ? this.activeBg : this.bg;\n            buffer.drawText(b.x, y, b.text, color, bgColor);\n            x = b.x + b.text.length;\n            buffer.drawText(x, y, this.separator, this.fg);\n        });\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Messages extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        super.init(opts);\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.length || 40,\n            match: (_x, _y) => {\n                if (this.parent)\n                    this.parent.requestRedraw();\n                return true;\n            },\n        });\n    }\n    click(e, ui) {\n        if (!this.contains(e))\n            return false;\n        return this.showArchive(ui).then(() => true);\n    }\n    draw(buffer) {\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, this.fg);\n            if (confirmed) {\n                buffer.mix(this.bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    async showArchive(ui) {\n        let reverse, fadePercent = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = this.cache.length;\n        if (totalMessageCount <= this.bounds.height)\n            return false;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = ui.startLayer();\n        const fg = GWU.color.from(this.fg);\n        totalMessageCount = Math.min(totalMessageCount, isOnTop ? dbuf.height - this.bounds.top : this.bounds.bottom + 1);\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            const dM = reverse ? -1 : 1;\n            const startM = reverse ? totalMessageCount : this.bounds.height;\n            const endM = reverse\n                ? this.bounds.height + dM + 1\n                : totalMessageCount + dM;\n            // console.log(\n            //     `setting up draw - startM=${startM}, endM=${endM}, dM=${dM}`\n            // );\n            for (let currentM = startM; currentM != endM; currentM += dM) {\n                const startY = isOnTop\n                    ? this.bounds.y + currentM - 1\n                    : this.bounds.bottom - currentM + 1;\n                const endY = isOnTop ? this.bounds.y : this.bounds.bottom;\n                const dy = isOnTop ? -1 : 1;\n                ui.resetLayerBuffer(dbuf);\n                // console.log(\n                //     `draw archive - count=${i}, startY=${startY}, endY=${endY}, dy=${dy}`\n                // );\n                dbuf.fillRect(this.bounds.x, Math.min(startY, endY), this.bounds.width, currentM, ' ', this.bg, this.bg);\n                this.cache.forEach((line, _confirmed, j) => {\n                    const y = startY + j * dy;\n                    if (isOnTop) {\n                        if (y < endY)\n                            return;\n                    }\n                    else if (y > endY)\n                        return;\n                    fadePercent = Math.floor((50 * j) / currentM);\n                    const fgColor = fg.clone().mix(this.bg, fadePercent);\n                    dbuf.drawText(this.bounds.x, y, line, fgColor, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward) {\n                    if (await ui.loop.pause(reverse ? 15 : 45)) {\n                        fastForward = true;\n                        currentM = endM - 2 * dM; // skip to the end-1\n                    }\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await ui.loop.waitForAck();\n            }\n        }\n        ui.finishLayer();\n        this.cache.confirmAll();\n        if (this.parent)\n            this.parent.requestRedraw(); // everything is confirmed\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    get baseBuffer() {\n        return this.layers[this.layers.length - 1] || this.canvas.buffer;\n    }\n    get canvasBuffer() {\n        return this.canvas.buffer;\n    }\n    startLayer() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetLayerBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishLayer() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n    // UTILITY FUNCTIONS\n    async fadeTo(color = 'black', duration = 1000) {\n        color = GWU.color.from(color);\n        const buffer = this.startLayer();\n        let pct = 0;\n        let elapsed = 0;\n        while (elapsed < duration) {\n            elapsed += 32;\n            if (await this.loop.pause(32)) {\n                elapsed = duration;\n            }\n            pct = Math.floor((100 * elapsed) / duration);\n            this.resetLayerBuffer(buffer);\n            buffer.mix(color, pct);\n            buffer.render();\n        }\n        this.finishLayer();\n    }\n    async alert(opts, text, args) {\n        if (typeof opts === 'number') {\n            opts = { duration: opts };\n        }\n        if (args) {\n            text = GWU.text.apply(text, args);\n        }\n        const padX = opts.padX || opts.pad || 1;\n        const padY = opts.padY || opts.pad || 1;\n        opts.width = opts.width || GWU.text.length(text) + padX * 2;\n        const textOpts = {\n            fg: opts.fg,\n            text,\n            x: padX,\n            y: padY,\n            wrap: opts.width - 2 * padX,\n        };\n        textOpts.text = text;\n        textOpts.wrap = opts.width;\n        const dlg = Widget.buildDialog(this, opts)\n            .with(new Widget.Text('TEXT', textOpts))\n            .center()\n            .done();\n        dlg.setClickHandlers({ click: () => dlg.close(true) }); // any click\n        dlg.setKeyHandlers({ keypress: () => dlg.close(true) }); // any key\n        dlg.setActionHandlers({ TIMEOUT: () => dlg.close(false) });\n        if (!opts.waitForAck) {\n            dlg.setTimeout('TIMEOUT', opts.duration || 3000);\n        }\n        return await dlg.show();\n    }\n    async confirm(...args) {\n        let opts;\n        let text;\n        let textArgs = null;\n        if (args.length <= 2 && typeof args[0] === 'string') {\n            opts = {};\n            text = args[0];\n            textArgs = args[1] || null;\n        }\n        else {\n            opts = args[0];\n            text = args[1];\n            textArgs = args[2] || null;\n        }\n        if (textArgs) {\n            text = GWU.text.apply(text, textArgs);\n        }\n        const padX = opts.padX || opts.pad || 1;\n        const padY = opts.padY || opts.pad || 1;\n        opts.width =\n            opts.width ||\n                Math.min(Math.floor(this.buffer.width / 2), GWU.text.length(text) + padX * 2);\n        let textWidth = opts.width - padX * 2;\n        const textOpts = {\n            fg: opts.fg,\n            text,\n            wrap: textWidth,\n        };\n        const textWidget = new Widget.Text('TEXT', textOpts);\n        opts.height = textWidget.bounds.height + 2 * padY + 2;\n        opts.allowCancel = opts.allowCancel !== false;\n        opts.buttons = Object.assign({\n            fg: 'white',\n            activeFg: 'teal',\n            bg: 'dark_gray',\n            activeBg: 'darkest_gray',\n        }, opts.buttons || {});\n        if (typeof opts.ok === 'string') {\n            opts.ok = { text: opts.ok };\n        }\n        if (typeof opts.cancel === 'string') {\n            opts.cancel = { text: opts.cancel };\n        }\n        opts.ok = opts.ok || {};\n        opts.cancel = opts.cancel || {};\n        const okOpts = Object.assign({}, opts.buttons, { text: 'OK', y: -padY, x: padX }, opts.ok);\n        const cancelOpts = Object.assign({}, opts.buttons, { text: 'CANCEL', y: -padY, x: -padX }, opts.cancel);\n        const builder = Widget.buildDialog(this, opts)\n            .with(textWidget)\n            .with(new Widget.Button('OK', okOpts));\n        if (opts.allowCancel) {\n            builder.with(new Widget.Button('CANCEL', cancelOpts));\n        }\n        const dlg = builder.center().done();\n        dlg.setClickHandlers({\n            OK() {\n                dlg.close(true);\n            },\n            CANCEL() {\n                dlg.close(false);\n            },\n        });\n        dlg.setKeyHandlers({\n            Escape() {\n                dlg.close(false);\n            },\n            Enter() {\n                dlg.close(true);\n            },\n        });\n        return await dlg.show();\n    }\n    // assumes you are in a dialog and give the buffer for that dialog\n    async getInputAt(x, y, maxLength, opts = {}) {\n        opts.width = maxLength;\n        opts.x = x;\n        opts.y = y;\n        const widget = new Widget.Input('INPUT', opts);\n        const buffer = this.startLayer();\n        await this.loop.run({\n            Enter: () => {\n                return true; // done\n            },\n            Escape: () => {\n                widget.text = '';\n                return true; // done\n            },\n            keypress: (e) => {\n                widget.keypress(e, this);\n            },\n            draw() {\n                widget.draw(buffer);\n                buffer.render();\n            },\n        });\n        this.finishLayer();\n        return widget.text;\n    }\n    async inputBox(opts, prompt, args) {\n        const padX = opts.padX || opts.pad || 1;\n        const padY = opts.padY || opts.pad || 1;\n        if (args) {\n            prompt = GWU.text.apply(prompt, args);\n        }\n        opts.width =\n            opts.width ||\n                Math.min(Math.floor(this.buffer.width / 2), GWU.text.length(prompt) + padX * 2);\n        let promptWidth = opts.width - padX * 2;\n        const promptOpts = {\n            fg: opts.fg,\n            text: prompt,\n            wrap: promptWidth,\n        };\n        const promptWidget = new Widget.Text('TEXT', promptOpts);\n        opts.height = promptWidget.bounds.height + 2 * padY + 4;\n        opts.allowCancel = opts.allowCancel !== false;\n        opts.buttons = Object.assign({\n            fg: 'white',\n            activeFg: 'teal',\n            bg: 'dark_gray',\n            activeBg: 'darkest_gray',\n        }, opts.buttons || {});\n        if (typeof opts.ok === 'string') {\n            opts.ok = { text: opts.ok };\n        }\n        if (typeof opts.cancel === 'string') {\n            opts.cancel = { text: opts.cancel };\n        }\n        opts.ok = opts.ok || {};\n        opts.cancel = opts.cancel || {};\n        const okOpts = Object.assign({}, opts.buttons, { text: 'OK', y: -padY, x: padX }, opts.ok);\n        const cancelOpts = Object.assign({}, opts.buttons, { text: 'CANCEL', y: -padY, x: -padX }, opts.cancel);\n        opts.input = opts.input || {};\n        opts.input.width = opts.input.width || promptWidth;\n        opts.input.bg = opts.input.bg || opts.fg;\n        opts.input.fg = opts.input.fg || opts.bg;\n        const inputWidget = new Widget.Input('INPUT', opts.input || {});\n        const builder = Widget.buildDialog(this, opts)\n            .with(promptWidget)\n            .with(inputWidget)\n            .with(new Widget.Button('OK', okOpts));\n        if (opts.allowCancel) {\n            builder.with(new Widget.Button('CANCEL', cancelOpts));\n        }\n        const dlg = builder.center().done();\n        dlg.setClickHandlers({\n            OK() {\n                dlg.close(inputWidget.text);\n            },\n            CANCEL() {\n                dlg.close('');\n            },\n        });\n        dlg.setKeyHandlers({\n            Escape() {\n                dlg.close('');\n            },\n            Enter() {\n                dlg.close(inputWidget.text);\n            },\n        });\n        return await dlg.show();\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Viewport extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n    }\n    init(opts) {\n        opts.bg = opts.bg || 'black';\n        super.init(opts);\n        this.snap = opts.snap || false;\n        this.center = opts.center || false;\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n        if (this.parent)\n            this.parent.requestRedraw();\n    }\n    set lock(v) {\n        this.lockX = v;\n        this.lockY = v;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.center = true;\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.center = false;\n        this.snap = false;\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.memory || subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    draw(buffer) {\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this.bg);\n        if (!this._subject) {\n            return false;\n        }\n        this.updateOffset();\n        const map = this._subject.memory || this._subject.map;\n        const fov = this._subject.fov;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this.bg, this.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["Widget","constructor","id","opts","this","active","hovered","tabStop","fg","bg","activeFg","activeBg","hoverFg","hoverBg","text","align","valign","bounds","GWU","xy","Bounds","init","reset","undefined","x","y","width","height","length","action","contains","arguments","mousemove","e","_ui","tick","_e","click","keypress","draw","buffer","textLen","fillRect","Math","floor","drawText","Text","Widget.Widget","super","wrap","lines","splitIntoLines","truncate","max","forEach","line","i","Button","_a","actionFn","Error","ev","r","parent","fireAction","then","key","Input","_b","_c","minLength","default","errorFg","hint","hintFg","numbersOnly","min","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","isValid","val","parseInt","value","textEntryBounds","spliceRaw","color","Dialog","ui","title","titleFg","borderBg","widgets","actionHandlers","keypressHandlers","clickHandlers","_activeWidget","result","done","timers","needsRedraw","activeWidget","w","requestRedraw","setTimeout","time","clearTimeout","widget","handler","setActionHandlers","map","setKeyHandlers","setClickHandlers","async","find","startLayer","loop","run","bind","render","finishLayer","close","returnValue","widgetAt","getWidget","nextTabstop","next","arrayNext","prevTabstop","prev","arrayPrev","dt","promises","Object","entries","push","Promise","all","fn","code","force","DialogBuilder","nextY","padY","padX","pad","dialog","with","addWidget","bottom","center","size","place","dlgBounds","buildDialog","install","EntryBase","dist","priority","changed","sidebarY","_buffer","_bounds","ActorEntry","actor","drawStatus","ItemEntry","item","CellEntry","cell","ActionButton","activate","DropDownButton","menu","buttons","addButton","config","button","setBounds","px","py","pw","right","totalWidth","totalHeight","buttonAt","index","dropBg","b","dropFg","showDropDown","activeButton","Escape","newActive","selected","getButtonAt","clearHighlight","actionButton","resetLayerBuffer","Widget.Text","promptFg","from","overflow","isPrompt","showText","capitalize","clear","showPrompt","getFlavorText","fov","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","separator","lead","_addButton","_y","arrayFindRight","reduce","len","dropdown","bgColor","cache","message","MessageCache","match","_x","showArchive","isOnTop","confirmed","mix","reverse","fastForward","fadePercent","totalMessageCount","dbuf","top","dM","startM","endM","currentM","startY","endY","dy","_confirmed","j","fgColor","clone","pause","wrapText","waitForAck","confirmAll","cellCache","lastX","lastY","lastMap","subject","highlight","entryAt","entry","highlightRow","last","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","clearMapFlag","_makeActorEntry","_makeItemEntry","_makeCellEntry","_getPriority","hasCellFlag","Cell","STABLE_MEMORY","_isDim","_addActorEntry","distanceBetween","isPlayer","_addItemEntry","_addCellEntry","findEntries","cx","cy","grid","alloc","eachActor","a","eachItem","c","sort","free","update","updateFor","updateAt","memory","drawBounds","currentEntry","usedLines","layers","freeBuffers","inDialog","canvas","baseBuffer","canvasBuffer","base","pop","Buffer","copy","dest","duration","pct","elapsed","args","textOpts","dlg","Widget.buildDialog","TIMEOUT","show","textArgs","textWidth","textWidget","allowCancel","assign","ok","cancel","okOpts","cancelOpts","builder","Widget.Button","OK","CANCEL","Enter","maxLength","Widget.Input","prompt","promptWidth","promptOpts","promptWidget","input","inputWidget","offsetX","offsetY","_subject","snap","filter","lock","lockX","lockY","halfWidth","halfHeight","v","toMapX","toMapY","toInnerX","toInnerY","centerOn","showMap","updateOffset","hasXY","left","edgeX","edgeY","thirdW","thirdH","clamp","blackOutRect","mixer","sprite","Mixer","mapX","mapY","drawer","drawCell","drawSprite"],"mappings":"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"}