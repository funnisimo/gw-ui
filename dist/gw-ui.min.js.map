{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/sidebar.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.fg = GWU.color.from((_a = opts.fg) !== null && _a !== void 0 ? _a : 'flavorText');\n        this.bg = GWU.color.from((_b = opts.bg) !== null && _b !== void 0 ? _b : 'black');\n        this.promptFg = GWU.color.from((_c = opts.promptFg) !== null && _c !== void 0 ? _c : 'flavorPrompt');\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? this.fg : this.promptFg;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, this.bg);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n        this.sidebarY = -1;\n    }\n    draw(_sidebar) { }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    draw(sidebar) {\n        this.actor.drawStatus(sidebar);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    draw(sidebar) {\n        this.item.drawStatus(sidebar);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(sidebar) {\n        this.cell.drawStatus(sidebar);\n    }\n}\nexport class Sidebar {\n    constructor(opts) {\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.mixer = new GWU.sprite.Mixer();\n        this.currentY = 0;\n        this.follow = null;\n        this.highlight = null;\n        this.currentEntry = null;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'purple');\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    toInnerY(y) {\n        return GWU.clamp(y - this.bounds.top, 0, this.bounds.height);\n    }\n    updateHighlight(e) {\n        if (!this.contains(e)) {\n            this.clearHighlight();\n            return false;\n        }\n        return this.highlightRow(this.toInnerY(e.y));\n    }\n    highlightRow(innerY) {\n        const y = GWU.clamp(innerY, 0, this.bounds.height);\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        if (this.highlight) {\n            // @ts-ignore\n            this.highlight.highlight = true;\n            return true;\n        }\n        return false;\n    }\n    clearHighlight() {\n        this.highlight = null;\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return !!this.highlight || entry.priority > 2;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this._addItemEntry(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    clearSidebar() {\n        this.ui.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n    }\n    drawFor(subject) {\n        return this.draw(subject.memory || subject.map, subject.x, subject.y, subject.fov);\n    }\n    draw(map, cx, cy, fov) {\n        if (arguments.length < 3) {\n            if (this.follow) {\n                return this.drawFor(this.follow);\n            }\n            throw new Error('Not following a subject - map, cx, cy required.');\n        }\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        this.clearSidebar();\n        this.currentY = this.bounds.y;\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        for (let i = 0; i < this.entries.length && this.currentY < this.bounds.bottom; ++i) {\n            this.currentEntry = this.entries[i];\n            this.currentEntry.sidebarY = this.currentY;\n            this.currentEntry.draw(this);\n            ++this.currentY; // skip a line\n        }\n        this.currentEntry = null;\n        return true;\n    }\n    drawTitle(cell, title, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this._isDim(this.currentEntry)\n            ? fg.clone().darken(50)\n            : fg;\n        this.buffer.drawSprite(this.bounds.x + 1, this.currentY, cell);\n        this.buffer.wrapText(this.bounds.x + 3, this.currentY, this.bounds.width - 3, title, fgColor);\n        ++this.currentY;\n    }\n    drawTextLine(text, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this._isDim(this.currentEntry)\n            ? fg.clone().darken(50)\n            : fg;\n        this.buffer.drawText(this.bounds.x + 3, this.currentY, text, fgColor, this.bounds.width - 3);\n        ++this.currentY;\n    }\n    drawProgressBar(val, max, text, color, bg, fg) {\n        color = GWU.color.from(color || this.fg);\n        bg = GWU.color.from(bg || color.clone().darken(50));\n        fg = GWU.color.from(fg || color.clone().lighten(50));\n        if (this._isDim(this.currentEntry)) {\n            bg.darken(50);\n            fg.darken(50);\n            color.darken(50);\n        }\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, this.bounds.width - 1, 1, undefined, undefined, bg);\n        const len = Math.floor(((this.bounds.width - 1) * val) / max);\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, len, 1, undefined, undefined, color);\n        const title = GWU.text.center(text, this.bounds.width);\n        this.buffer.drawText(this.bounds.x + 1, this.currentY, title, fg, undefined, this.bounds.width - 1 // just in case title is too long\n        );\n        ++this.currentY;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.center = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this._follow = null;\n        this.ui = opts.ui;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    get follow() {\n        return this._follow;\n    }\n    set follow(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n            this.centerOn(subject.x, subject.y, subject.map);\n        }\n        this._follow = subject;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(x, y, map) {\n        this.center = true;\n        this.updateOffset({ x, y }, map);\n    }\n    updateOffset(focus, map) {\n        const bounds = map || this.bounds;\n        if (focus && GWU.xy.contains(bounds, focus.x, focus.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (focus.x < left || focus.x > right) {\n                    left = this.offsetX = focus.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (focus.y < top || focus.y > bottom) {\n                    top = this.offsetY = focus.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= focus.x) {\n                    this.offsetX = Math.max(0, focus.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= focus.x) {\n                    this.offsetX = Math.min(focus.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= focus.y) {\n                    this.offsetY = Math.max(0, focus.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= focus.y) {\n                    this.offsetY = Math.min(focus.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = focus.x - this.halfWidth();\n                this.offsetY = focus.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = focus.x;\n                this.offsetY = focus.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    drawFor(subject) {\n        if (!subject.map)\n            throw new Error('No map!');\n        return this.draw(subject.memory || subject.map, subject.fov);\n    }\n    draw(map, fov) {\n        if (!map) {\n            if (!this._follow)\n                throw new Error('Either map or follow must be set.');\n            return this.drawFor(this._follow);\n        }\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        this.updateOffset(this._follow, map);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["color","install","EntryBase","constructor","this","dist","priority","changed","sidebarY","draw","_sidebar","ActorEntry","actor","super","x","y","sidebar","drawStatus","ItemEntry","item","CellEntry","cell","opts","_a","_b","_c","text","needsUpdate","isPrompt","overflow","ui","bounds","GWU","xy","Bounds","width","fg","from","bg","promptFg","showText","capitalize","clear","showPrompt","force","buffer","nextY","wrapText","render","getFlavorText","map","fov","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","Math","min","height","cache","message","MessageCache","length","contains","e","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","loop","pause","waitForAck","finishDialog","confirmAll","cellCache","lastX","lastY","lastMap","entries","mixer","sprite","Mixer","currentY","follow","highlight","currentEntry","toInnerY","clamp","top","updateHighlight","highlightRow","clearHighlight","innerY","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","push","clearMapFlag","_makeActorEntry","_makeItemEntry","_makeCellEntry","_getPriority","hasCellFlag","Cell","STABLE_MEMORY","_isDim","entry","_addActorEntry","distanceBetween","isPlayer","_addItemEntry","_addCellEntry","findEntries","cx","cy","done","grid","alloc","eachActor","a","eachItem","sort","b","free","clearSidebar","drawFor","subject","memory","arguments","Error","bottom","drawTitle","title","fgColor","darken","drawSprite","drawTextLine","drawText","drawProgressBar","val","max","lighten","undefined","len","center","layers","freeBuffers","inDialog","canvas","base","pop","Buffer","dest","snap","filter","offsetX","offsetY","lockX","lockY","_follow","lock","halfWidth","halfHeight","centerOn","toMapX","toMapY","toInnerX","updateOffset","focus","left","right","edgeX","edgeY","thirdW","thirdH","mapX","mapY","hasXY","drawer","drawCell","blackOut"],"mappings":"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"}