{"version":3,"file":"gw-ui.min.js","sources":["../js/message.js","../js/ui.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        this.overlay = null;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.overlay || this.buffer;\n        this.layers.push(base);\n        this.overlay =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.overlay.copy(base);\n        return this.overlay;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.overlay) {\n            this.freeBuffers.push(this.overlay);\n        }\n        this.overlay = this.layers.pop() || this.buffer;\n        this.overlay.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n"],"names":["constructor","opts","buffer","ui","this","bounds","GWU","xy","Bounds","x","y","Math","min","width","height","cache","message","MessageCache","length","bg","color","from","fg","contains","needsUpdate","draw","force","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","text","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","wrapText","render","loop","pause","waitForAck","finishDialog","confirmAll","layers","freeBuffers","inDialog","overlay","canvas","Error","base","push","pop","Buffer","dest"],"mappings":"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"}