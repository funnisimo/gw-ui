{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/sidebar.js","../js/menu.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.fg = GWU.color.from((_a = opts.fg) !== null && _a !== void 0 ? _a : 'flavorText');\n        this.bg = GWU.color.from((_b = opts.bg) !== null && _b !== void 0 ? _b : 'black');\n        this.promptFg = GWU.color.from((_c = opts.promptFg) !== null && _c !== void 0 ? _c : 'flavorPrompt');\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? this.fg : this.promptFg;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, this.bg);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n        this.sidebarY = -1;\n    }\n    draw(_sidebar) { }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    draw(sidebar) {\n        this.actor.drawStatus(sidebar);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    draw(sidebar) {\n        this.item.drawStatus(sidebar);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(sidebar) {\n        this.cell.drawStatus(sidebar);\n    }\n}\nexport class Sidebar {\n    constructor(opts) {\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.mixer = new GWU.sprite.Mixer();\n        this.currentY = 0;\n        this.follow = null;\n        this.highlight = null;\n        this.currentEntry = null;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'purple');\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    toInnerY(y) {\n        return GWU.clamp(y - this.bounds.top, 0, this.bounds.height);\n    }\n    updateHighlight(e) {\n        if (!this.contains(e)) {\n            this.clearHighlight();\n            return false;\n        }\n        return this.highlightRow(this.toInnerY(e.y));\n    }\n    highlightRow(innerY) {\n        const y = GWU.clamp(innerY, 0, this.bounds.height);\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        if (this.highlight) {\n            // @ts-ignore\n            this.highlight.highlight = true;\n            return true;\n        }\n        return false;\n    }\n    clearHighlight() {\n        this.highlight = null;\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return !!this.highlight || entry.priority > 2;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this._addItemEntry(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    clearSidebar() {\n        this.ui.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n    }\n    drawFor(subject) {\n        return this.draw(subject.memory || subject.map, subject.x, subject.y, subject.fov);\n    }\n    draw(map, cx, cy, fov) {\n        if (arguments.length < 3) {\n            if (this.follow) {\n                return this.drawFor(this.follow);\n            }\n            throw new Error('Not following a subject - map, cx, cy required.');\n        }\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        this.clearSidebar();\n        this.currentY = this.bounds.y;\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        for (let i = 0; i < this.entries.length && this.currentY < this.bounds.bottom; ++i) {\n            this.currentEntry = this.entries[i];\n            this.currentEntry.sidebarY = this.currentY;\n            this.currentEntry.draw(this);\n            ++this.currentY; // skip a line\n        }\n        this.currentEntry = null;\n        return true;\n    }\n    drawTitle(cell, title, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this._isDim(this.currentEntry)\n            ? fg.clone().darken(50)\n            : fg;\n        this.buffer.drawSprite(this.bounds.x + 1, this.currentY, cell);\n        this.buffer.wrapText(this.bounds.x + 3, this.currentY, this.bounds.width - 3, title, fgColor);\n        ++this.currentY;\n    }\n    drawTextLine(text, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this._isDim(this.currentEntry)\n            ? fg.clone().darken(50)\n            : fg;\n        this.buffer.drawText(this.bounds.x + 3, this.currentY, text, fgColor, this.bounds.width - 3);\n        ++this.currentY;\n    }\n    drawProgressBar(val, max, text, color, bg, fg) {\n        color = GWU.color.from(color || this.fg);\n        bg = GWU.color.from(bg || color.clone().darken(50));\n        fg = GWU.color.from(fg || color.clone().lighten(50));\n        if (this._isDim(this.currentEntry)) {\n            bg.darken(50);\n            fg.darken(50);\n            color.darken(50);\n        }\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, this.bounds.width - 1, 1, undefined, undefined, bg);\n        const len = Math.floor(((this.bounds.width - 1) * val) / max);\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, len, 1, undefined, undefined, color);\n        const title = GWU.text.center(text, this.bounds.width);\n        this.buffer.drawText(this.bounds.x + 1, this.currentY, title, fg, undefined, this.bounds.width - 1 // just in case title is too long\n        );\n        ++this.currentY;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Button {\n    constructor(text) {\n        this.hovered = false;\n        this.x = 999;\n        this.text = text;\n    }\n    get width() {\n        return this.text.length;\n    }\n}\nexport class ActionButton extends Button {\n    constructor(text, fn) {\n        super(text);\n        this.fn = fn;\n    }\n    activate() {\n        return this.fn(this);\n    }\n}\nexport class DropDownButton extends Button {\n    constructor(menu, parent, text, buttons) {\n        super(text);\n        this.buttons = [];\n        this.parent = null;\n        this.menu = menu;\n        this.parent = parent;\n        this.text = text;\n        this.bounds = new GWU.xy.Bounds(0, 0, 0, 0);\n        Object.entries(buttons).forEach(([text, opts]) => {\n            this.addButton(text, opts);\n        });\n    }\n    addButton(text, config) {\n        if (this.buttons.length >= this.menu.ui.buffer.height - 1) {\n            throw new Error('Too many menu options.');\n        }\n        let button;\n        if (typeof config === 'function') {\n            button = new ActionButton(text, config);\n        }\n        else {\n            button = new DropDownButton(this.menu, this, text, config);\n        }\n        this.buttons.push(button);\n        ++this.bounds.height;\n        this.bounds.width = Math.max(this.bounds.width, text.length + 2);\n    }\n    setBounds(px, py, pwidth) {\n        const right = px + pwidth;\n        const left = px;\n        const totalWidth = this.menu.ui.buffer.width;\n        if (this.bounds.width < totalWidth - right) {\n            this.bounds.x = right;\n        }\n        else if (this.bounds.width < left) {\n            this.bounds.x = left - this.bounds.width;\n        }\n        else {\n            throw new Error('Menu does not fit - too wide.');\n        }\n        const totalHeight = this.menu.ui.buffer.height;\n        if (this.bounds.height <= totalHeight - py) {\n            this.bounds.y = py;\n        }\n        else if (this.bounds.height < totalHeight) {\n            this.bounds.y = totalHeight - this.bounds.height - 1;\n        }\n        else {\n            throw new Error('Menu does not fit - too tall.');\n        }\n        this.buttons.forEach((b, i) => {\n            if (b instanceof DropDownButton) {\n                b.setBounds(this.bounds.x, this.bounds.y + i, this.bounds.width);\n            }\n        });\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    buttonAt(e) {\n        const index = e.y - this.bounds.y;\n        return this.buttons[index] || null;\n    }\n    drawInto(buffer) {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n        const x = this.bounds.x;\n        let y = this.bounds.y;\n        buffer.fillRect(x, y, width, height, 0, 0, this.menu.dropBg);\n        // Now draw the individual buttons...\n        this.buttons.forEach((b) => {\n            buffer.drawText(x + 1, y, b.text, b.hovered ? this.menu.hoverFg : this.menu.dropFg, b.hovered ? this.menu.hoverBg : this.menu.dropBg);\n            ++y;\n        });\n        if (this.parent) {\n            this.parent.drawInto(buffer);\n        }\n    }\n}\nexport async function showDropDown(menu, button) {\n    const ui = button.menu.ui;\n    // Start dialog\n    const dialog = ui.startDialog();\n    let activeButton = button;\n    await ui.loop.run({\n        Escape() {\n            return true;\n        },\n        mousemove: (e) => {\n            if (!activeButton)\n                return true; // we are done (should not happen)\n            let newActive = activeButton;\n            while (newActive && !newActive.contains(e)) {\n                newActive = newActive.parent;\n            }\n            if (newActive) {\n                activeButton = newActive;\n                const selected = activeButton.buttonAt(e);\n                if (selected) {\n                    activeButton.buttons.forEach((b) => {\n                        b.hovered = false;\n                    });\n                    selected.hovered = true;\n                    if (selected instanceof DropDownButton) {\n                        activeButton = selected;\n                    }\n                }\n            }\n            else {\n                if (menu.contains(e)) {\n                    menu.needsRedraw = true;\n                    const button = menu.getButtonAt(e.x, e.y);\n                    if (button instanceof DropDownButton) {\n                        activeButton.hovered = false;\n                        activeButton = button;\n                        activeButton.hovered = true;\n                    }\n                    else {\n                        activeButton = null; // done.\n                        if (button)\n                            button.hovered = true;\n                    }\n                }\n            }\n            return !activeButton; // if no active button we are done (should not happen)\n        },\n        click: async (e) => {\n            if (!activeButton)\n                return true; // we are done (should not happen)\n            if (!activeButton.contains(e)) {\n                menu.clearHighlight();\n                return true; // we are done\n            }\n            const actionButton = activeButton.buttonAt(e);\n            if (!actionButton) {\n                return true; // weird, but we are done.\n            }\n            if (actionButton instanceof ActionButton) {\n                return actionButton.activate(); // actions return true if they want to close the menu (otherwise the menu stays open)\n            }\n        },\n        draw: () => {\n            if (!activeButton)\n                return;\n            ui.resetDialogBuffer(dialog);\n            activeButton.drawInto(dialog);\n            menu.drawInto(dialog);\n            dialog.render();\n        },\n    });\n    ui.finishDialog();\n    menu.clearHighlight();\n}\nexport class Menu {\n    constructor(opts) {\n        this.buttons = [];\n        this.separator = ' | ';\n        this.lead = ' ';\n        this.needsRedraw = false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.ui = opts.ui;\n        this.needsRedraw = true;\n        this.fg = GWU.color.from(opts.fg || 'black');\n        this.bg = GWU.color.from(opts.bg || 'light_gray');\n        this.hoverFg = opts.hoverFg\n            ? GWU.color.from(opts.hoverFg)\n            : this.fg.clone().lighten(50);\n        this.hoverBg = opts.hoverBg\n            ? GWU.color.from(opts.hoverBg)\n            : this.bg.clone().darken(50);\n        this.dropFg = opts.dropFg\n            ? GWU.color.from(opts.dropFg)\n            : this.fg.clone();\n        this.dropBg = opts.dropBg\n            ? GWU.color.from(opts.dropBg)\n            : this.bg.clone();\n        Object.entries(opts.buttons).forEach(([text, opts]) => {\n            this.addButton(text, opts);\n        });\n        if (opts.separator) {\n            this.separator = opts.separator;\n        }\n        if (opts.lead !== undefined) {\n            this.lead = opts.lead ? opts.lead : '';\n        }\n    }\n    contains(e) {\n        return this.bounds.contains(e);\n    }\n    handleMouse(e) {\n        // turn off all the hovers\n        this.buttons.forEach((b) => {\n            if (b.hovered) {\n                this.needsRedraw = true;\n                b.hovered = false;\n            }\n        });\n        // highlight one of them...\n        if (this.bounds.contains(e.x, e.y)) {\n            this.needsRedraw = true;\n            let hovered = null;\n            this.buttons.forEach((b) => {\n                b.hovered = false;\n                if (b.x < e.x) {\n                    hovered = b;\n                }\n            });\n            if (hovered) {\n                // @ts-ignore\n                hovered.hovered = true;\n            }\n            return true; // we handled the message\n        }\n        return false;\n    }\n    clearHighlight() {\n        this.buttons.forEach((b) => {\n            b.hovered = false;\n        });\n        this.needsRedraw = true;\n    }\n    getButtonAt(x, _y) {\n        return GWU.arrayFindRight(this.buttons, (b) => b.x < x) || null;\n    }\n    async handleClick(e) {\n        if (this.bounds.contains(e.x, e.y)) {\n            // get active button\n            let activeButton = this.getButtonAt(e.x, e.y);\n            if (!activeButton)\n                return false;\n            if (activeButton instanceof DropDownButton) {\n                await showDropDown(this, activeButton);\n            }\n            else if (activeButton instanceof ActionButton) {\n                await activeButton.activate();\n            }\n            return true;\n        }\n        return false;\n    }\n    addButton(text, config) {\n        this.needsRedraw = true;\n        const x = this.buttons.reduce((len, button) => len + button.text.length + this.separator.length, this.lead.length + this.bounds.x);\n        if (x + text.length + 2 > this.bounds.width) {\n            throw new Error('Button makes menu too wide :' + text);\n        }\n        let button;\n        if (typeof config === 'function') {\n            button = new ActionButton(text, config);\n        }\n        else {\n            button = new DropDownButton(this, null, text, config);\n            button.setBounds(x - 1, this.bounds.y ? this.bounds.y - 1 : 1, 0);\n        }\n        button.x = x;\n        this.buttons.push(button);\n    }\n    draw(force = false) {\n        if (!this.needsRedraw && !force)\n            return false;\n        const buffer = this.ui.buffer;\n        return this.drawInto(buffer);\n    }\n    drawInto(buffer) {\n        this.needsRedraw = false;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, 1, 0, 0, this.bg);\n        let x = this.bounds.x;\n        const y = this.bounds.y;\n        buffer.drawText(x, y, this.lead, this.fg);\n        this.buttons.forEach((b) => {\n            const color = b.hovered ? this.hoverFg : this.fg;\n            const bgColor = b.hovered ? this.hoverBg : this.bg;\n            buffer.drawText(b.x, y, b.text, color, bgColor);\n            x = b.x + b.text.length;\n            buffer.drawText(x, y, this.separator, this.fg);\n        });\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n    // assumes you are in a dialog and give the buffer for that dialog\n    async getInputAt(x, y, maxLength, opts = {}) {\n        let numbersOnly = opts.numbersOnly || false;\n        const textEntryBounds = numbersOnly ? ['0', '9'] : [' ', '~'];\n        const buffer = this.startDialog();\n        maxLength = Math.min(maxLength, buffer.width - x);\n        const minLength = opts.minLength || 1;\n        let inputText = opts.default || '';\n        let charNum = GWU.text.length(inputText);\n        const fg = GWU.color.from(opts.fg || 'white');\n        const bg = GWU.color.from(opts.bg || 'dark_gray');\n        const errorFg = GWU.color.from(opts.errorFg || 'red');\n        const promptFg = opts.promptFg ? GWU.color.from(opts.promptFg) : 'gray';\n        function isValid(text) {\n            if (numbersOnly) {\n                const val = Number.parseInt(text);\n                if (opts.min !== undefined && val < opts.min)\n                    return false;\n                if (opts.max !== undefined && val > opts.max)\n                    return false;\n                return val > 0;\n            }\n            return text.length >= minLength;\n        }\n        let ev;\n        do {\n            buffer.fillRect(x, y, maxLength, 1, ' ', fg, bg);\n            if (!inputText.length && opts.prompt && opts.prompt.length) {\n                buffer.drawText(x, y, opts.prompt, promptFg);\n            }\n            else {\n                const color = isValid(inputText) ? fg : errorFg;\n                buffer.drawText(x, y, inputText, color);\n            }\n            buffer.render();\n            ev = await this.loop.nextKeyPress(-1);\n            if (!ev || !ev.key)\n                continue;\n            if ((ev.key == 'Delete' || ev.key == 'Backspace') && charNum > 0) {\n                buffer.draw(x + charNum - 1, y, ' ', fg);\n                charNum--;\n                inputText = GWU.text.spliceRaw(inputText, charNum, 1);\n            }\n            else if (ev.key.length > 1) {\n                // ignore other special keys...\n            }\n            else if (ev.key >= textEntryBounds[0] &&\n                ev.key <= textEntryBounds[1]) {\n                // allow only permitted input\n                if (charNum < maxLength) {\n                    inputText += ev.key;\n                    charNum++;\n                }\n            }\n            if (ev.key == 'Escape') {\n                this.finishDialog();\n                return '';\n            }\n        } while (!isValid(inputText) || !ev || ev.key != 'Enter');\n        this.finishDialog();\n        // GW.ui.draw(); // reverts to old display\n        return inputText;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.center = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this._follow = null;\n        this.ui = opts.ui;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    get follow() {\n        return this._follow;\n    }\n    set follow(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n            this.centerOn(subject.x, subject.y, subject.map);\n        }\n        this._follow = subject;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(x, y, map) {\n        this.center = true;\n        this.updateOffset({ x, y }, map);\n    }\n    updateOffset(focus, map) {\n        const bounds = map || this.bounds;\n        if (focus && GWU.xy.contains(bounds, focus.x, focus.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (focus.x < left || focus.x > right) {\n                    left = this.offsetX = focus.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (focus.y < top || focus.y > bottom) {\n                    top = this.offsetY = focus.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= focus.x) {\n                    this.offsetX = Math.max(0, focus.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= focus.x) {\n                    this.offsetX = Math.min(focus.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= focus.y) {\n                    this.offsetY = Math.max(0, focus.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= focus.y) {\n                    this.offsetY = Math.min(focus.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = focus.x - this.halfWidth();\n                this.offsetY = focus.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = focus.x;\n                this.offsetY = focus.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    drawFor(subject) {\n        if (!subject.map)\n            throw new Error('No map!');\n        return this.draw(subject.memory || subject.map, subject.fov);\n    }\n    draw(map, fov) {\n        if (!map) {\n            if (!this._follow)\n                throw new Error('Either map or follow must be set.');\n            return this.drawFor(this._follow);\n        }\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        this.updateOffset(this._follow, map);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["color","install","EntryBase","constructor","this","dist","priority","changed","sidebarY","draw","_sidebar","ActorEntry","actor","super","x","y","sidebar","drawStatus","ItemEntry","item","CellEntry","cell","Button","text","hovered","width","length","ActionButton","fn","activate","DropDownButton","menu","parent","buttons","bounds","GWU","xy","Bounds","Object","entries","forEach","opts","addButton","config","ui","buffer","height","Error","button","push","Math","max","setBounds","px","py","pwidth","right","left","totalWidth","totalHeight","b","i","contains","e","buttonAt","index","drawInto","fillRect","dropBg","drawText","hoverFg","dropFg","hoverBg","async","showDropDown","dialog","startDialog","activeButton","loop","run","Escape","mousemove","newActive","selected","needsRedraw","getButtonAt","click","clearHighlight","actionButton","resetDialogBuffer","render","finishDialog","_a","_b","_c","needsUpdate","isPrompt","overflow","fg","from","bg","promptFg","showText","capitalize","clear","showPrompt","force","nextY","wrapText","getFlavorText","map","fov","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","separator","lead","clone","lighten","darken","undefined","handleMouse","_y","arrayFindRight","reduce","len","bgColor","min","cache","message","MessageCache","messageColor","tempColor","make","isOnTop","msg","confirmed","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","_confirmed","floor","pause","waitForAck","confirmAll","cellCache","lastX","lastY","lastMap","mixer","sprite","Mixer","currentY","follow","highlight","currentEntry","toInnerY","clamp","top","updateHighlight","highlightRow","innerY","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","clearMapFlag","_makeActorEntry","_makeItemEntry","_makeCellEntry","_getPriority","hasCellFlag","Cell","STABLE_MEMORY","_isDim","entry","_addActorEntry","distanceBetween","isPlayer","_addItemEntry","_addCellEntry","findEntries","cx","cy","done","grid","alloc","eachActor","a","eachItem","sort","free","clearSidebar","drawFor","subject","memory","arguments","bottom","drawTitle","title","fgColor","drawSprite","drawTextLine","drawProgressBar","val","center","layers","freeBuffers","inDialog","canvas","base","pop","Buffer","dest","maxLength","numbersOnly","textEntryBounds","minLength","inputText","default","charNum","errorFg","isValid","Number","parseInt","ev","prompt","nextKeyPress","key","spliceRaw","snap","filter","offsetX","offsetY","lockX","lockY","_follow","lock","halfWidth","halfHeight","centerOn","toMapX","toMapY","toInnerX","updateOffset","focus","edgeX","edgeY","thirdW","thirdH","mapX","mapY","hasXY","drawer","drawCell","blackOut"],"mappings":"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"}