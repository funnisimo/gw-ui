{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/sidebar.js","../js/menu.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.fg = GWU.color.from((_a = opts.fg) !== null && _a !== void 0 ? _a : 'flavorText');\n        this.bg = GWU.color.from((_b = opts.bg) !== null && _b !== void 0 ? _b : 'black');\n        this.promptFg = GWU.color.from((_c = opts.promptFg) !== null && _c !== void 0 ? _c : 'flavorPrompt');\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? this.fg : this.promptFg;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, this.bg);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n        this.sidebarY = -1;\n    }\n    draw(_sidebar) { }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    draw(sidebar) {\n        this.actor.drawStatus(sidebar);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    draw(sidebar) {\n        this.item.drawStatus(sidebar);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(sidebar) {\n        this.cell.drawStatus(sidebar);\n    }\n}\nexport class Sidebar {\n    constructor(opts) {\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.mixer = new GWU.sprite.Mixer();\n        this.currentY = 0;\n        this.follow = null;\n        this.highlight = null;\n        this.currentEntry = null;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'purple');\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    toInnerY(y) {\n        return GWU.clamp(y - this.bounds.top, 0, this.bounds.height);\n    }\n    updateHighlight(e) {\n        if (!this.contains(e)) {\n            this.clearHighlight();\n            return false;\n        }\n        return this.highlightRow(this.toInnerY(e.y));\n    }\n    highlightRow(innerY) {\n        const y = GWU.clamp(innerY, 0, this.bounds.height);\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        if (this.highlight) {\n            // @ts-ignore\n            this.highlight.highlight = true;\n            return true;\n        }\n        return false;\n    }\n    clearHighlight() {\n        this.highlight = null;\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return !!this.highlight || entry.priority > 2;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this._addItemEntry(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    clearSidebar() {\n        this.ui.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n    }\n    drawFor(subject) {\n        return this.draw(subject.memory || subject.map, subject.x, subject.y, subject.fov);\n    }\n    draw(map, cx, cy, fov) {\n        if (arguments.length < 3) {\n            if (this.follow) {\n                return this.drawFor(this.follow);\n            }\n            throw new Error('Not following a subject - map, cx, cy required.');\n        }\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        this.clearSidebar();\n        this.currentY = this.bounds.y;\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        for (let i = 0; i < this.entries.length && this.currentY < this.bounds.bottom; ++i) {\n            this.currentEntry = this.entries[i];\n            this.currentEntry.sidebarY = this.currentY;\n            this.currentEntry.draw(this);\n            ++this.currentY; // skip a line\n        }\n        this.currentEntry = null;\n        return true;\n    }\n    drawTitle(cell, title, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this._isDim(this.currentEntry)\n            ? fg.clone().darken(50)\n            : fg;\n        this.buffer.drawSprite(this.bounds.x + 1, this.currentY, cell);\n        this.buffer.wrapText(this.bounds.x + 3, this.currentY, this.bounds.width - 3, title, fgColor);\n        ++this.currentY;\n    }\n    drawTextLine(text, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this._isDim(this.currentEntry)\n            ? fg.clone().darken(50)\n            : fg;\n        this.buffer.drawText(this.bounds.x + 3, this.currentY, text, fgColor, this.bounds.width - 3);\n        ++this.currentY;\n    }\n    drawProgressBar(val, max, text, color, bg, fg) {\n        color = GWU.color.from(color || this.fg);\n        bg = GWU.color.from(bg || color.clone().darken(50));\n        fg = GWU.color.from(fg || color.clone().lighten(50));\n        if (this._isDim(this.currentEntry)) {\n            bg.darken(50);\n            fg.darken(50);\n            color.darken(50);\n        }\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, this.bounds.width - 1, 1, undefined, undefined, bg);\n        const len = Math.floor(((this.bounds.width - 1) * val) / max);\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, len, 1, undefined, undefined, color);\n        const title = GWU.text.center(text, this.bounds.width);\n        this.buffer.drawText(this.bounds.x + 1, this.currentY, title, fg, undefined, this.bounds.width - 1 // just in case title is too long\n        );\n        ++this.currentY;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Button {\n    constructor(menu, opts) {\n        this.x = -1;\n        this.hovered = false;\n        this.menu = menu;\n        this.text = opts.text;\n        this.fn = opts.fn || GWU.NOOP;\n    }\n    contains(_e) {\n        return false;\n    }\n    handleMouse(_e) {\n        return false;\n    }\n    async click() {\n        await this.fn(this);\n    }\n    draw(buffer, x, y) {\n        const color = this.hovered ? this.menu.hoverFg : this.menu.fg;\n        const len = GWU.text.length(this.text);\n        buffer.drawText(x, y, this.text, color);\n        return x + len;\n    }\n}\nexport class Menu {\n    constructor(opts) {\n        this.buttons = [];\n        this.separator = ' | ';\n        this.lead = ' ';\n        this.needsRedraw = false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.ui = opts.ui;\n        this.needsRedraw = true;\n        this.fg = GWU.color.from(opts.fg || 'white');\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.hoverFg = GWU.color.from(opts.hoverFg || 'teal');\n        this.hoverBg = GWU.color.from(opts.hoverBg || 'black');\n        if (opts.buttons) {\n            if (Array.isArray(opts.buttons)) {\n                opts.buttons.forEach((b) => this.addButton(b));\n            }\n            else {\n                Object.entries(opts.buttons).forEach(([text, opts]) => {\n                    if (typeof opts === 'function') {\n                        opts = { fn: opts };\n                    }\n                    opts.text = text;\n                    this.addButton(opts);\n                });\n            }\n        }\n        if (opts.separator) {\n            this.separator = opts.separator;\n        }\n        if (opts.lead !== undefined) {\n            this.lead = opts.lead ? opts.lead : '';\n        }\n    }\n    contains(e) {\n        if (this.bounds.contains(e.x, e.y))\n            return true;\n        return this.buttons.some((b) => b.contains(e));\n    }\n    handleMouse(e) {\n        if (this.bounds.contains(e.x, e.y)) {\n            this.needsRedraw = true;\n            let hovered = null;\n            this.buttons.forEach((b) => {\n                b.hovered = false;\n                if (b.x < e.x) {\n                    hovered = b;\n                }\n            });\n            if (hovered) {\n                // @ts-ignore\n                hovered.hovered = true;\n            }\n            return true;\n        }\n        for (let b of this.buttons) {\n            if (b.contains(e)) {\n                return b.handleMouse(e);\n            }\n        }\n        this.buttons.forEach((b) => {\n            if (b.hovered) {\n                this.needsRedraw = true;\n                b.hovered = false;\n            }\n        });\n        return false;\n    }\n    async handleClick(e) {\n        if (this.bounds.contains(e.x, e.y)) {\n            let clicked = null;\n            this.buttons.forEach((b) => {\n                if (b.x < e.x) {\n                    clicked = b;\n                }\n            });\n            this.needsRedraw = true;\n            if (clicked) {\n                // @ts-ignore\n                await clicked.click();\n                return true;\n            }\n        }\n        return false;\n    }\n    addButton(opts) {\n        this.needsRedraw = true;\n        const length = this.buttons.reduce((len, button) => len + button.text.length + 2, 0);\n        if (length + opts.text.length + 2 > this.bounds.width) {\n            throw new Error('Button makes menu too wide :' + opts.text);\n        }\n        const button = new Button(this, opts);\n        this.buttons.push(button);\n    }\n    draw() {\n        if (!this.needsRedraw)\n            return false;\n        this.needsRedraw = false;\n        const buffer = this.ui.buffer;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, 1, 0, 0, 0);\n        let x = this.bounds.x;\n        const y = this.bounds.y;\n        buffer.drawText(x, y, this.lead, this.fg);\n        x += this.lead.length;\n        this.buttons.forEach((b) => {\n            b.x = x;\n            x = b.draw(buffer, x, y);\n            buffer.drawText(x, y, this.separator, this.fg);\n            x += this.separator.length;\n        });\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.center = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this._follow = null;\n        this.ui = opts.ui;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    get follow() {\n        return this._follow;\n    }\n    set follow(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n            this.centerOn(subject.x, subject.y, subject.map);\n        }\n        this._follow = subject;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(e) {\n        return this.bounds.contains(e.x, e.y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(x, y, map) {\n        this.center = true;\n        this.updateOffset({ x, y }, map);\n    }\n    updateOffset(focus, map) {\n        const bounds = map || this.bounds;\n        if (focus && GWU.xy.contains(bounds, focus.x, focus.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (focus.x < left || focus.x > right) {\n                    left = this.offsetX = focus.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (focus.y < top || focus.y > bottom) {\n                    top = this.offsetY = focus.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= focus.x) {\n                    this.offsetX = Math.max(0, focus.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= focus.x) {\n                    this.offsetX = Math.min(focus.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= focus.y) {\n                    this.offsetY = Math.max(0, focus.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= focus.y) {\n                    this.offsetY = Math.min(focus.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = focus.x - this.halfWidth();\n                this.offsetY = focus.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = focus.x;\n                this.offsetY = focus.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    drawFor(subject) {\n        if (!subject.map)\n            throw new Error('No map!');\n        return this.draw(subject.memory || subject.map, subject.fov);\n    }\n    draw(map, fov) {\n        if (!map) {\n            if (!this._follow)\n                throw new Error('Either map or follow must be set.');\n            return this.drawFor(this._follow);\n        }\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        this.updateOffset(this._follow, map);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["color","install","EntryBase","constructor","this","dist","priority","changed","sidebarY","draw","_sidebar","ActorEntry","actor","super","x","y","sidebar","drawStatus","ItemEntry","item","CellEntry","cell","Button","menu","opts","hovered","text","fn","GWU","NOOP","contains","_e","handleMouse","async","buffer","hoverFg","fg","len","length","drawText","_a","_b","_c","needsUpdate","isPrompt","overflow","ui","bounds","xy","Bounds","width","from","bg","promptFg","showText","capitalize","clear","showPrompt","force","nextY","wrapText","render","getFlavorText","map","fov","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","buttons","separator","lead","needsRedraw","hoverBg","Array","isArray","forEach","b","addButton","Object","entries","undefined","e","some","clicked","click","reduce","button","Error","push","fillRect","Math","min","height","cache","message","MessageCache","messageColor","tempColor","make","isOnTop","msg","confirmed","i","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","loop","pause","waitForAck","finishDialog","confirmAll","cellCache","lastX","lastY","lastMap","mixer","sprite","Mixer","currentY","follow","highlight","currentEntry","toInnerY","clamp","top","updateHighlight","highlightRow","clearHighlight","innerY","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","clearMapFlag","_makeActorEntry","_makeItemEntry","_makeCellEntry","_getPriority","hasCellFlag","Cell","STABLE_MEMORY","_isDim","entry","_addActorEntry","distanceBetween","isPlayer","_addItemEntry","_addCellEntry","findEntries","cx","cy","done","grid","alloc","eachActor","a","eachItem","sort","free","clearSidebar","drawFor","subject","memory","arguments","bottom","drawTitle","title","fgColor","darken","drawSprite","drawTextLine","drawProgressBar","val","max","lighten","center","layers","freeBuffers","inDialog","canvas","base","pop","Buffer","dest","snap","filter","offsetX","offsetY","lockX","lockY","_follow","lock","halfWidth","halfHeight","centerOn","toMapX","toMapY","toInnerX","updateOffset","focus","left","right","edgeX","edgeY","thirdW","thirdH","mapX","mapY","hasXY","drawer","drawCell","blackOut"],"mappings":"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"}