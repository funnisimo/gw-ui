{"version":3,"file":"gw-ui.min.js","sources":["../js/game/message.js","../js/game/flavor.js","../js/game/sidebar.js","../js/game/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nexport class Messages extends GWU.widget.Widget {\n    constructor(layer, opts) {\n        super(layer, (() => {\n            opts.tag = opts.tag || 'messages';\n            return opts;\n        })());\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.length || 40,\n            match: (_x, _y) => {\n                this.layer.needsDraw = true;\n                return true;\n            },\n        });\n    }\n    click(e) {\n        if (!this.contains(e))\n            return false;\n        this._showArchive();\n        return true;\n    }\n    draw(buffer) {\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this._used.bg, this._used.bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, this._used.fg);\n            if (confirmed && this._used.bg) {\n                buffer.mix(this._used.bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    _showArchive() {\n        if (this.cache.length <= this.bounds.height)\n            return;\n        showArchive(this);\n    }\n}\nexport class MessageArchive extends GWU.widget.Widget {\n    constructor(layer, source) {\n        super(layer, {\n            id: 'ARCHIVE',\n            tag: 'messages',\n            class: source.classes.concat('archive').join(' '),\n            height: source.bounds.height,\n            width: source.bounds.width,\n            x: 0,\n            y: 0,\n            tabStop: true,\n            depth: 100, // I'm on top\n        });\n        this.mode = 'forward';\n        this._timeout = null;\n        this.source = source;\n        this.isOnTop = this.source.bounds.y < 10;\n        this.bounds.height = this.isOnTop\n            ? layer.height - source.bounds.y\n            : source.bounds.bottom;\n        this.totalCount = Math.min(source.cache.length, this.isOnTop\n            ? layer.height - this.source.bounds.top\n            : this.source.bounds.bottom);\n        this.shown = source.bounds.height;\n        this._timeout = this.layer.setTimeout(() => this._forward(), 16);\n        // confirm them as they are right now...\n        this.source.cache.confirmAll();\n    }\n    contains() {\n        return true; // Eat all mouse activity\n    }\n    finish() {\n        this.layer.finish();\n    }\n    keypress(e) {\n        return this.click(e);\n    }\n    click(_e) {\n        if (this.mode === 'ack') {\n            this.mode = 'reverse';\n            this.layer.needsDraw = true;\n            if (this._timeout) {\n                this.layer.clearTimeout(this._timeout);\n            }\n            this._timeout = this.layer.setTimeout(() => this._reverse(), 16);\n        }\n        else if (this.mode === 'reverse') {\n            this.finish();\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n            if (this._timeout) {\n                this.layer.clearTimeout(this._timeout);\n                this._timeout = null;\n            }\n            this.layer.needsDraw = true;\n        }\n        return true;\n    }\n    _forward() {\n        // console.log('forward');\n        ++this.shown;\n        this._timeout = null;\n        this.layer.needsDraw = true;\n        if (this.shown < this.totalCount) {\n            this._timeout = this.layer.setTimeout(() => this._forward(), 16);\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n        }\n        return true;\n    }\n    _reverse() {\n        // console.log('reverse');\n        --this.shown;\n        this._timeout = null;\n        if (this.shown <= this.source.bounds.height) {\n            this.finish();\n        }\n        else {\n            this.layer.needsDraw = true;\n            this._timeout = this.layer.setTimeout(() => this._reverse(), 16);\n        }\n        return true;\n    }\n    _draw(buffer) {\n        let fadePercent = 0;\n        // let reverse = this.mode === 'reverse';\n        // Count the number of lines in the archive.\n        // let totalMessageCount = this.totalCount;\n        const isOnTop = this.isOnTop;\n        const dbuf = buffer;\n        const fg = GWU.color.from(this.source._used.fg);\n        // const dM = reverse ? -1 : 1;\n        // const startM = reverse ? totalMessageCount : this.bounds.height;\n        // const endM = reverse\n        //     ? this.bounds.height + dM + 1\n        //     : totalMessageCount + dM;\n        const startY = isOnTop\n            ? this.shown - 1\n            : this.bounds.bottom - this.shown;\n        const endY = isOnTop ? 0 : this.bounds.bottom - 1;\n        const dy = isOnTop ? -1 : 1;\n        dbuf.fillRect(this.source.bounds.x, Math.min(startY, endY), this.bounds.width, this.shown, ' ', this._used.bg, this._used.bg);\n        this.source.cache.forEach((line, _confirmed, j) => {\n            const y = startY + j * dy;\n            if (isOnTop) {\n                if (y < endY)\n                    return;\n            }\n            else if (y > endY)\n                return;\n            fadePercent = Math.floor((50 * j) / this.shown);\n            const fgColor = fg.mix(this._used.bg, fadePercent);\n            dbuf.drawText(this.source.bounds.x, y, line, fgColor, this._used.bg);\n        });\n        if (this.mode === 'ack') {\n            const y = this.isOnTop ? 0 : dbuf.height - 1;\n            const x = this.source.bounds.x > 8\n                ? this.source.bounds.x - 8 // to left of box\n                : Math.min(this.source.bounds.x + this.bounds.width, // just to right of box\n                dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                );\n            dbuf.wrapText(x, y, 8, '--DONE--', this._used.bg, this._used.fg);\n        }\n        return true;\n    }\n}\nexport async function showArchive(widget) {\n    const layer = new GWU.widget.WidgetLayer(widget.layer.ui);\n    // @ts-ignore\n    const w = new MessageArchive(layer, widget);\n    await layer.run();\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor extends GWU.widget.Text {\n    constructor(layer, opts) {\n        super(layer, (() => {\n            opts.tag = opts.tag || 'flavor';\n            opts.text = '';\n            return opts;\n        })());\n        this.overflow = opts.overflow || false;\n        this.isPrompt = false;\n    }\n    showText(text) {\n        this.text(text);\n        this.removeClass('prompt');\n        return this;\n    }\n    clear() {\n        this.text('');\n        this.removeClass('prompt');\n        return this;\n    }\n    showPrompt(text) {\n        this.showText(text);\n        this.addClass('prompt');\n        return this;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'You see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'You sense';\n        }\n        else if (isRemembered) {\n            intro = 'You remember';\n        }\n        else if (isMapped) {\n            intro = 'You expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n        this.sidebarY = -1;\n    }\n    draw(_buffer, _bounds) {\n        return 0;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    draw(buffer, bounds) {\n        return this.actor.drawStatus(buffer, bounds);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    draw(buffer, bounds) {\n        return this.item.drawStatus(buffer, bounds);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(buffer, bounds) {\n        return this.cell.drawStatus(buffer, bounds);\n    }\n}\nexport class Sidebar extends GWU.widget.Widget {\n    constructor(layer, opts) {\n        super(layer, opts);\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.subject = null;\n        this.highlight = null;\n    }\n    reset() {\n        this.lastMap = null;\n        this.lastX = -1;\n        this.lastY = -1;\n    }\n    entryAt(e) {\n        return (this.entries.find((entry) => {\n            return entry.sidebarY <= e.y && entry.sidebarY !== -1;\n        }) || null);\n    }\n    mousemove(e) {\n        super.mousemove(e);\n        if (this.contains(e)) {\n            return this.highlightRow(e.y);\n        }\n        return this.clearHighlight();\n    }\n    highlightRow(y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        return this.highlight !== last;\n    }\n    clearHighlight() {\n        const result = !!this.highlight;\n        this.highlight = null;\n        return result;\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return entry.priority > 2 || !!this.highlight;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this._addItemEntry(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    update() {\n        if (!this.subject) {\n            throw new Error('Update requires a subject to follow.');\n        }\n        return this.updateFor(this.subject);\n    }\n    updateFor(subject) {\n        return this.updateAt(subject.memory || subject.map, subject.x, subject.y, subject.fov);\n    }\n    updateAt(map, cx, cy, fov) {\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        return true;\n    }\n    draw(buffer) {\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this._used.bg);\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        const drawBounds = this.bounds.clone();\n        let currentEntry;\n        for (let i = 0; i < this.entries.length && drawBounds.height > 0; ++i) {\n            currentEntry = this.entries[i];\n            currentEntry.sidebarY = drawBounds.y;\n            let usedLines = currentEntry.draw(buffer, drawBounds);\n            if (this._isDim(currentEntry) && this._used.bg) {\n                buffer.mix(this._used.bg, 50, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            if (usedLines) {\n                ++usedLines; // skip a space\n                drawBounds.y += usedLines;\n                drawBounds.height -= usedLines;\n            }\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport extends GWU.widget.Widget {\n    constructor(layer, opts) {\n        super(layer, opts);\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n        this.attr('snap', opts.snap || false);\n        this.attr('center', opts.center || false);\n        this.filter = opts.filter || null;\n        this.attr('lockX', opts.lock || opts.lockX || false);\n        this.attr('lockY', opts.lock || opts.lockY || false);\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.attr('center', !!subject);\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n    }\n    set lock(v) {\n        this.attr('lockX', v);\n        this.attr('lockY', v);\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.attr('center', true);\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.attr('center', false);\n        this.attr('snap', false);\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.memory || subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this._attrBool('snap')) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this._attrBool('center')) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this._attrBool('lockX') && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this._attrBool('lockY') && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    draw(buffer) {\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this._used.bg);\n        if (!this._subject) {\n            return false;\n        }\n        this.updateOffset();\n        const map = this._subject.memory || this._subject.map;\n        const fov = this._subject.fov;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this._used.bg, this._used.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["Messages","GWU","widget","Widget","constructor","layer","opts","super","tag","this","bounds","height","Error","cache","message","MessageCache","width","length","match","_x","_y","needsDraw","click","e","contains","_showArchive","draw","buffer","isOnTop","y","fillRect","x","_used","bg","forEach","line","confirmed","i","drawText","fg","mix","showArchive","MessageArchive","source","id","class","classes","concat","join","tabStop","depth","mode","_timeout","bottom","totalCount","Math","min","top","shown","setTimeout","_forward","confirmAll","finish","keypress","_e","clearTimeout","_reverse","_draw","fadePercent","dbuf","color","from","startY","endY","dy","_confirmed","j","floor","fgColor","wrapText","async","WidgetLayer","ui","run","install","Flavor","Text","text","overflow","isPrompt","showText","removeClass","clear","showPrompt","addClass","getFlavorText","map","fov","cell","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","actor","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","EntryBase","dist","priority","changed","sidebarY","_buffer","_bounds","ActorEntry","drawStatus","ItemEntry","item","CellEntry","Sidebar","cellCache","lastX","lastY","lastMap","entries","subject","highlight","reset","entryAt","find","entry","mousemove","highlightRow","clearHighlight","last","result","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","xy","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","push","clearMapFlag","_makeActorEntry","_makeItemEntry","_makeCellEntry","_getPriority","hasCellFlag","Cell","STABLE_MEMORY","_isDim","_addActorEntry","distanceBetween","isPlayer","_addItemEntry","_addCellEntry","findEntries","cx","cy","done","grid","alloc","eachActor","a","eachItem","c","sort","b","free","update","updateFor","updateAt","memory","drawBounds","clone","currentEntry","usedLines","Viewport","offsetX","offsetY","_subject","attr","snap","center","filter","lock","lockX","lockY","halfWidth","halfHeight","v","toMapX","toMapY","toInnerX","toInnerY","centerOn","showMap","updateOffset","hasXY","_attrBool","left","right","edgeX","edgeY","thirdW","max","thirdH","clamp","blackOutRect","mixer","sprite","Mixer","mapX","mapY","drawer","drawCell","drawSprite"],"mappings":"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"}