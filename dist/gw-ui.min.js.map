{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/sidebar.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.fg = GWU.color.from((_a = opts.fg) !== null && _a !== void 0 ? _a : 'flavorText');\n        this.bg = GWU.color.from((_b = opts.bg) !== null && _b !== void 0 ? _b : 'black');\n        this.promptFg = GWU.color.from((_c = opts.promptFg) !== null && _c !== void 0 ? _c : 'flavorPrompt');\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? this.fg : this.promptFg;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, this.bg);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.actor || null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.item;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n}\nexport class Sidebar {\n    constructor(opts) {\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    addActor(actor, map, x, y, fov) {\n        const priority = this.getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this.makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    addItem(item, map, x, y, fov) {\n        const priority = this.getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this.makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    addCell(cell, map, x, y, fov) {\n        const priority = this.getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this.makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this.addActor(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this.addItem(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this.addCell(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    clearSidebar() {\n        this.ui.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n    }\n    update(map, cx, cy, fov) {\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        this.clearSidebar();\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.follow = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this.ui = opts.ui;\n        this.follow = opts.follow || false;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    draw(map, playerX, playerY) {\n        if (!map)\n            return false;\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        if (this.follow && playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX - this.halfWidth();\n            this.offsetY = playerY - this.halfHeight();\n        }\n        else if (this.snap &&\n            playerX !== undefined &&\n            playerY !== undefined) {\n            const left = this.offsetX;\n            const right = this.offsetX + this.bounds.width;\n            const top = this.offsetY;\n            const bottom = this.offsetY + this.bounds.height;\n            const edgeX = Math.floor(this.bounds.width / 5);\n            const edgeY = Math.floor(this.bounds.height / 5);\n            const thirdW = Math.floor(this.bounds.width / 3);\n            if (left + edgeX >= playerX) {\n                this.offsetX = Math.max(0, playerX + thirdW - this.bounds.width);\n            }\n            else if (right - edgeX <= playerX) {\n                this.offsetX = Math.min(playerX - thirdW, map.width - this.bounds.width);\n            }\n            const thirdH = Math.floor(this.bounds.height / 3);\n            if (top + edgeY >= playerY) {\n                this.offsetY = Math.max(0, playerY + thirdH - this.bounds.height);\n            }\n            else if (bottom - edgeY <= playerY) {\n                this.offsetY = Math.min(playerY - thirdH, map.height - this.bounds.height);\n            }\n        }\n        else if (playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX;\n            this.offsetY = playerY;\n        }\n        if (this.lockX) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    map.getAppearanceAt(mapX, mapY, mixer);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["color","install","EntryBase","constructor","this","dist","priority","changed","ActorEntry","actor","super","ItemEntry","item","CellEntry","cell","opts","_a","_b","_c","text","needsUpdate","isPrompt","overflow","ui","bounds","GWU","xy","Bounds","x","y","width","fg","from","bg","promptFg","showText","capitalize","draw","clear","showPrompt","force","buffer","nextY","wrapText","render","getFlavorText","map","fov","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","theItem","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","Math","min","height","cache","message","MessageCache","length","contains","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","loop","pause","waitForAck","finishDialog","confirmAll","cellCache","lastX","lastY","lastMap","entries","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","push","clearMapFlag","makeActorEntry","makeItemEntry","makeCellEntry","getPriority","hasCellFlag","Cell","STABLE_MEMORY","addActor","entry","distanceBetween","isPlayer","addItem","addCell","findEntries","cx","cy","done","grid","alloc","eachActor","a","eachItem","sort","b","free","clearSidebar","update","layers","freeBuffers","inDialog","canvas","Error","base","pop","Buffer","dest","follow","snap","filter","offsetX","offsetY","lockX","lockY","lock","toMapX","toMapY","toInnerX","toInnerY","halfWidth","halfHeight","playerX","playerY","undefined","left","right","top","bottom","edgeX","edgeY","thirdW","max","thirdH","clamp","mixer","sprite","Mixer","mapX","mapY","hasXY","getAppearanceAt","blackOut","drawSprite"],"mappings":"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"}