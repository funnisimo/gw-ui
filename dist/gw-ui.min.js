!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("gw-utils"),require("gw-map")):"function"==typeof define&&define.amd?define(["exports","gw-utils","gw-map"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).GWI={},t.GWU,t.GWM)}(this,(function(t,i,s){"use strict";function e(t){if(t&&t.__esModule)return t;var i=Object.create(null);return t&&Object.keys(t).forEach((function(s){if("default"!==s){var e=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(i,s,e.get?e:{enumerable:!0,get:function(){return t[s]}})}})),i.default=t,Object.freeze(i)}var h=e(i),r=e(s);h.color.install("flavorText",50,40,90),h.color.install("flavorPrompt",100,90,20);h.color.install("blueBar",15,10,50),h.color.install("redBar",45,10,15),h.color.install("purpleBar",50,0,50),h.color.install("greenBar",10,50,10);class o{constructor(){this.dist=0,this.priority=0,this.changed=!1,this.sidebarY=-1}draw(t){}}class n extends o{constructor(t){super(),this.actor=t}get x(){return this.actor.x}get y(){return this.actor.y}draw(t){this.actor.drawStatus(t)}}class a extends o{constructor(t){super(),this.item=t}get x(){return this.item.x}get y(){return this.item.y}draw(t){this.item.drawStatus(t)}}class l extends o{constructor(t){super(),this.cell=t}get x(){return this.cell.x}get y(){return this.cell.y}draw(t){this.cell.drawStatus(t)}}class u{constructor(t){this.hovered=!1,this.x=999,this.text=t}get width(){return this.text.length}}class d extends u{constructor(t,i){super(t),this.fn=i}activate(){return this.fn(this)}}class c extends u{constructor(t,i,s,e){super(s),this.buttons=[],this.parent=null,this.menu=t,this.parent=i,this.text=s,this.bounds=new h.xy.Bounds(0,0,0,0),Object.entries(e).forEach((([t,i])=>{this.addButton(t,i)}))}addButton(t,i){if(this.buttons.length>=this.menu.ui.buffer.height-1)throw new Error("Too many menu options.");let s;s="function"==typeof i?new d(t,i):new c(this.menu,this,t,i),this.buttons.push(s),++this.bounds.height,this.bounds.width=Math.max(this.bounds.width,t.length+2)}setBounds(t,i,s){const e=t+s,h=t,r=this.menu.ui.buffer.width;if(this.bounds.width<r-e)this.bounds.x=e;else{if(!(this.bounds.width<h))throw new Error("Menu does not fit - too wide.");this.bounds.x=h-this.bounds.width}const o=this.menu.ui.buffer.height;if(this.bounds.height<=o-i)this.bounds.y=i;else{if(!(this.bounds.height<o))throw new Error("Menu does not fit - too tall.");this.bounds.y=o-this.bounds.height-1}this.buttons.forEach(((t,i)=>{t instanceof c&&t.setBounds(this.bounds.x,this.bounds.y+i,this.bounds.width)}))}contains(t){return this.bounds.contains(t.x,t.y)}buttonAt(t){const i=t.y-this.bounds.y;return this.buttons[i]||null}drawInto(t){const i=this.bounds.width,s=this.bounds.height,e=this.bounds.x;let h=this.bounds.y;t.fillRect(e,h,i,s,0,0,this.menu.dropBg),this.buttons.forEach((i=>{t.drawText(e+1,h,i.text,i.hovered?this.menu.hoverFg:this.menu.dropFg,i.hovered?this.menu.hoverBg:this.menu.dropBg),++h})),this.parent&&this.parent.drawInto(t)}}async function f(t,i){const s=i.menu.ui,e=s.startDialog();let h=i;await s.loop.run({Escape:()=>!0,mousemove:i=>{if(!h)return!0;let s=h;for(;s&&!s.contains(i);)s=s.parent;if(s){h=s;const t=h.buttonAt(i);t&&(h.buttons.forEach((t=>{t.hovered=!1})),t.hovered=!0,t instanceof c&&(h=t))}else if(t.contains(i)){t.needsRedraw=!0;const s=t.getButtonAt(i.x,i.y);s instanceof c?(h.hovered=!1,h=s,h.hovered=!0):(h=null,s&&(s.hovered=!0))}return!h},click:async i=>{if(!h)return!0;if(!h.contains(i))return t.clearHighlight(),!0;const s=h.buttonAt(i);return!s||(s instanceof d?s.activate():void 0)},draw:()=>{h&&(s.resetDialogBuffer(e),h.drawInto(e),t.drawInto(e),e.render())}}),s.finishDialog(),t.clearHighlight()}t.ActionButton=d,t.ActorEntry=n,t.Button=u,t.CellEntry=l,t.DropDownButton=c,t.EntryBase=o,t.Flavor=class{constructor(t){var i,s,e;this.text="",this.needsUpdate=!1,this.isPrompt=!1,this.overflow=!1,this.ui=t.ui,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,1),this.fg=h.color.from(null!==(i=t.fg)&&void 0!==i?i:"flavorText"),this.bg=h.color.from(null!==(s=t.bg)&&void 0!==s?s:"black"),this.promptFg=h.color.from(null!==(e=t.promptFg)&&void 0!==e?e:"flavorPrompt")}showText(t){this.text=h.text.capitalize(t),this.needsUpdate=!0,this.isPrompt=!1,this.draw()}clear(){this.text="",this.needsUpdate=!0,this.isPrompt=!1,this.draw()}showPrompt(t){this.text=h.text.capitalize(t),this.needsUpdate=!0,this.isPrompt=!0,this.draw()}draw(t=!1){if(!t&&!this.needsUpdate)return!1;const i=this.ui.buffer,s=this.isPrompt?this.fg:this.promptFg,e=i.wrapText(this.bounds.x,this.bounds.y,this.bounds.width,this.text,s,this.bg);return this.overflow=e!==this.bounds.y+1,this.ui.render(),this.needsUpdate=!1,!0}getFlavorText(t,i,s,e){const o=t.cell(i,s);let n,a="";const l=!e||e.isAnyKindOfVisible(i,s),u=!e||e.isDirectlyVisible(i,s),d=!!e&&e.isRevealed(i,s),c=!!e&&e.isMagicMapped(i,s);let f;if(u)f="you see";else if(l)f="you sense";else if(d)f="you remember";else{if(!c)return"";f="you expect to see"}const g=o.hasActor()?t.actorAt(i,s):null,b=o.hasItem()?t.itemAt(i,s):null,w=o.hasTileFlag(r.flags.Tile.T_STAND_IN_TILE);let p=!1;g?(a=g.getFlavor({color:!1,article:!0,action:!0}),p=!0):b&&(a=b.getFlavor({color:!1,article:!0}),p=!0);let y=w?" in ":" on ";const x=o.depthTile(r.flags.Depth.GROUND)||r.tile.tiles.NULL,m=o.depthTile(r.flags.Depth.SURFACE),v=o.depthTile(r.flags.Depth.LIQUID);let E="";if(m){p&&(p=!1,a+=" on "),m.hasTileFlag(r.flags.Tile.T_BRIDGE)&&(y=" over "),E=m.getFlavor()+y}let B="";v&&(B=v.getFlavor()+" covering ",p&&(p=!1,a+=" in ")),p&&(p=!1,a+=" on ");let M=x.getFlavor({article:!0});return n=h.text.apply("§intro§ §text§.",{intro:f,text:a+E+B+M}),n}},t.ItemEntry=a,t.Menu=class{constructor(t){this.buttons=[],this.separator=" | ",this.lead=" ",this.needsRedraw=!1,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,1),this.ui=t.ui,this.needsRedraw=!0,this.fg=h.color.from(t.fg||"black"),this.bg=h.color.from(t.bg||"light_gray"),this.hoverFg=t.hoverFg?h.color.from(t.hoverFg):this.fg.clone().lighten(50),this.hoverBg=t.hoverBg?h.color.from(t.hoverBg):this.bg.clone().darken(50),this.dropFg=t.dropFg?h.color.from(t.dropFg):this.fg.clone(),this.dropBg=t.dropBg?h.color.from(t.dropBg):this.bg.clone(),Object.entries(t.buttons).forEach((([t,i])=>{this.addButton(t,i)})),t.separator&&(this.separator=t.separator),void 0!==t.lead&&(this.lead=t.lead?t.lead:"")}contains(t){return this.bounds.contains(t)}handleMouse(t){if(this.buttons.forEach((t=>{t.hovered&&(this.needsRedraw=!0,t.hovered=!1)})),this.bounds.contains(t.x,t.y)){this.needsRedraw=!0;let i=null;return this.buttons.forEach((s=>{s.hovered=!1,s.x<t.x&&(i=s)})),i&&(i.hovered=!0),!0}return!1}clearHighlight(){this.buttons.forEach((t=>{t.hovered=!1})),this.needsRedraw=!0}getButtonAt(t,i){return h.arrayFindRight(this.buttons,(i=>i.x<t))||null}async handleClick(t){if(this.bounds.contains(t.x,t.y)){let i=this.getButtonAt(t.x,t.y);return!!i&&(i instanceof c?await f(this,i):i instanceof d&&await i.activate(),!0)}return!1}addButton(t,i){this.needsRedraw=!0;const s=this.buttons.reduce(((t,i)=>t+i.text.length+this.separator.length),this.lead.length+this.bounds.x);if(s+t.length+2>this.bounds.width)throw new Error("Button makes menu too wide :"+t);let e;"function"==typeof i?e=new d(t,i):(e=new c(this,null,t,i),e.setBounds(s-1,this.bounds.y?this.bounds.y-1:1,0)),e.x=s,this.buttons.push(e)}draw(t=!1){if(!this.needsRedraw&&!t)return!1;const i=this.ui.buffer;return this.drawInto(i)}drawInto(t){this.needsRedraw=!1,t.fillRect(this.bounds.x,this.bounds.y,this.bounds.width,1,0,0,this.bg);let i=this.bounds.x;const s=this.bounds.y;return t.drawText(i,s,this.lead,this.fg),this.buttons.forEach((e=>{const h=e.hovered?this.hoverFg:this.fg,r=e.hovered?this.hoverBg:this.bg;t.drawText(e.x,s,e.text,h,r),i=e.x+e.text.length,t.drawText(i,s,this.separator,this.fg)})),!0}},t.Messages=class{constructor(t){const i=t.ui.buffer;this.bounds=new h.xy.Bounds(t.x,t.y,Math.min(t.width||i.width,i.width-t.x),Math.min(t.height||i.height,i.height-t.y)),this.cache=new h.message.MessageCache({width:this.bounds.width,length:i.height}),this.ui=t.ui,this.bg=h.color.from(t.bg||"black"),this.fg=h.color.from(t.fg||"white")}contains(t){return this.bounds.contains(t.x,t.y)}get needsUpdate(){return this.cache.needsUpdate}get buffer(){return this.ui.buffer}draw(t=!1){if(!t&&!this.cache.needsUpdate)return!1;let i;const s=h.color.make(),e=this.bounds.y<10;return this.buffer.fillRect(this.bounds.x,this.bounds.y,this.bounds.width,this.bounds.height," ",0,this.bg),this.cache.forEach(((t,r,o)=>{if(o>=this.bounds.height)return;i=s,i.copy(this.fg),r&&(i.mix(this.bg,50),i.mix(this.bg,75*o/(2*this.bounds.height)));const n=e?this.bounds.height-o-1:o,a=this.toBufferY(n);h.text.eachChar(t,((t,e,h,n)=>{const l=this.toBufferX(n);e&&i!==e&&r&&(e.mix(this.bg,50),e.mix(this.bg,75*o/(2*this.bounds.height))),i=e||s,this.buffer.draw(l,a,t,i,this.bg)}))})),this.cache.needsUpdate=!1,!0}toBufferY(t){return this.bounds.y+t}toBufferX(t){return this.bounds.x+t}async showArchive(){let t,i,s,e=0,h=0;if(this.cache.forEach((()=>++h)),h<=this.bounds.height)return;const r=this.bounds.y<10,o=this.ui.startDialog();for(t=0;t<=1;t++){for(s=!1,e=t?h:this.bounds.height;t?e>=this.bounds.height:e<=h;e+=t?-1:1)this.ui.resetDialogBuffer(o),this.cache.forEach(((t,s,h)=>{if(h>=e||h>=o.height)return;const n=r?h:o.height-h-1;i=Math.floor(50*(e-h)/e);const a=this.fg.clone().mix(this.bg,i);o.wrapText(this.toBufferX(0),n,this.bounds.width,t,a,this.bg)})),o.render(),!s&&await this.ui.loop.pause(t?15:45)&&(s=!0,e=t?this.bounds.height+1:h-1);if(!t){const t=r?0:o.height-1,i=this.bounds.x>8?this.bounds.x-8:Math.min(this.bounds.x+this.bounds.width,this.buffer.width-8);o.wrapText(i,t,8,"--DONE--",this.bg,this.fg),o.render(),await this.ui.loop.waitForAck()}}this.ui.finishDialog(),this.cache.confirmAll(),this.cache.needsUpdate=!0}},t.Sidebar=class{constructor(t){this.cellCache=[],this.lastX=-1,this.lastY=-1,this.lastMap=null,this.entries=[],this.mixer=new h.sprite.Mixer,this.currentY=0,this.follow=null,this.highlight=null,this.currentEntry=null,this.ui=t.ui,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,t.height),this.bg=h.color.from(t.bg||"black"),this.fg=h.color.from(t.fg||"purple")}get buffer(){return this.ui.buffer}contains(t){return this.bounds.contains(t.x,t.y)}toInnerY(t){return h.clamp(t-this.bounds.top,0,this.bounds.height)}updateHighlight(t){return this.contains(t)?this.highlightRow(this.toInnerY(t.y)):(this.clearHighlight(),!1)}highlightRow(t){const i=h.clamp(t,0,this.bounds.height);return this.highlight=null,this.entries.forEach((t=>{t.sidebarY<=i&&-1!==t.sidebarY&&(this.highlight=t)})),!!this.highlight&&(this.highlight.highlight=!0,!0)}clearHighlight(){this.highlight=null}updateCellCache(t){this.lastMap&&t===this.lastMap&&!t.hasMapFlag(r.flags.Map.MAP_SIDEBAR_TILES_CHANGED)||(this.lastMap=null,this.cellCache.length=0,h.xy.forRect(t.width,t.height,((i,s)=>{const e=t.cell(i,s);e.hasEntityFlag(r.flags.Entity.L_LIST_IN_SIDEBAR)&&this.cellCache.push(e)})),t.clearMapFlag(r.flags.Map.MAP_SIDEBAR_TILES_CHANGED))}_makeActorEntry(t){return new n(t)}_makeItemEntry(t){return new a(t)}_makeCellEntry(t){return new l(t)}_getPriority(t,i,s,e){return e?e.isDirectlyVisible(i,s)?1:e.isAnyKindOfVisible(i,s)?2:e.isRevealed(i,s)?3:-1:t.cell(i,s).hasCellFlag(r.flags.Cell.STABLE_MEMORY)?3:1}_isDim(t){return t!==this.highlight&&(!!this.highlight||t.priority>2)}_addActorEntry(t,i,s,e,r){const o=this._getPriority(i,t.x,t.y,r);if(o<0)return!1;const n=this._makeActorEntry(t);return n.dist=h.xy.distanceBetween(s,e,t.x,t.y),n.priority=t.isPlayer()?0:o,this.entries.push(n),!0}_addItemEntry(t,i,s,e,r){const o=this._getPriority(i,t.x,t.y,r);if(o<0)return!1;const n=this._makeItemEntry(t);return n.dist=h.xy.distanceBetween(s,e,t.x,t.y),n.priority=o,this.entries.push(n),!0}_addCellEntry(t,i,s,e,r){const o=this._getPriority(i,t.x,t.y,r);if(o<0)return!1;const n=this._makeCellEntry(t);return n.dist=h.xy.distanceBetween(s,e,t.x,t.y),n.priority=o,this.entries.push(n),!0}findEntries(t,i,s,e){if(t===this.lastMap&&i===this.lastX&&s===this.lastY)return;this.clearHighlight(),this.lastMap=t,this.lastX=i,this.lastY=s,this.entries.length=0;const r=h.grid.alloc(t.width,t.height);t.eachActor((h=>{const o=h.x,n=h.y;r[o][n]||this._addActorEntry(h,t,i,s,e)&&(r[o][n]=1)})),t.eachItem((h=>{const o=h.x,n=h.y;r[o][n]||this._addItemEntry(h,t,i,s,e)&&(r[o][n]=1)})),this.cellCache.forEach((h=>{r[h.x][h.y]||this._addCellEntry(h,t,i,s,e)&&(r[h.x][h.y]=1)})),this.entries.sort(((t,i)=>t.priority!=i.priority?t.priority-i.priority:t.dist-i.dist)),h.grid.free(r)}clearSidebar(){this.ui.buffer.fillRect(this.bounds.x,this.bounds.y,this.bounds.width,this.bounds.height,0,0,this.bg)}drawFor(t){return this.draw(t.memory||t.map,t.x,t.y,t.fov)}draw(t,i,s,e){if(arguments.length<3){if(this.follow)return this.drawFor(this.follow);throw new Error("Not following a subject - map, cx, cy required.")}this.updateCellCache(t),this.findEntries(t,i,s,e),this.clearSidebar(),this.currentY=this.bounds.y,this.entries.forEach((t=>t.sidebarY=-1));for(let t=0;t<this.entries.length&&this.currentY<this.bounds.bottom;++t)this.currentEntry=this.entries[t],this.currentEntry.sidebarY=this.currentY,this.currentEntry.draw(this),++this.currentY;return this.currentEntry=null,!0}drawTitle(t,i,s){s=h.color.from(s||this.fg);const e=this._isDim(this.currentEntry)?s.clone().darken(50):s;this.buffer.drawSprite(this.bounds.x+1,this.currentY,t),this.buffer.wrapText(this.bounds.x+3,this.currentY,this.bounds.width-3,i,e),++this.currentY}drawTextLine(t,i){i=h.color.from(i||this.fg);const s=this._isDim(this.currentEntry)?i.clone().darken(50):i;this.buffer.drawText(this.bounds.x+3,this.currentY,t,s,this.bounds.width-3),++this.currentY}drawProgressBar(t,i,s,e,r,o){e=h.color.from(e||this.fg),r=h.color.from(r||e.clone().darken(50)),o=h.color.from(o||e.clone().lighten(50)),this._isDim(this.currentEntry)&&(r.darken(50),o.darken(50),e.darken(50)),this.buffer.fillRect(this.bounds.x+1,this.currentY,this.bounds.width-1,1,void 0,void 0,r);const n=Math.floor((this.bounds.width-1)*t/i);this.buffer.fillRect(this.bounds.x+1,this.currentY,n,1,void 0,void 0,e);const a=h.text.center(s,this.bounds.width);this.buffer.drawText(this.bounds.x+1,this.currentY,a,o,void 0,this.bounds.width-1),++this.currentY}},t.UI=class{constructor(t={}){if(this.layers=[],this.freeBuffers=[],this.inDialog=!1,!t.canvas)throw new Error("Need a canvas.");this.canvas=t.canvas,this.buffer=t.canvas.buffer,this.loop=t.loop||h.loop}render(){this.buffer.render()}startDialog(){this.inDialog=!0;const t=this.buffer||this.canvas.buffer;return this.layers.push(t),this.buffer=this.freeBuffers.pop()||new h.canvas.Buffer(this.canvas),this.buffer.copy(t),this.buffer}resetDialogBuffer(t){const i=this.layers[this.layers.length-1]||this.canvas.buffer;t.copy(i)}finishDialog(){this.inDialog&&(this.buffer!==this.canvas.buffer&&this.freeBuffers.push(this.buffer),this.buffer=this.layers.pop()||this.canvas.buffer,this.buffer.render(),this.inDialog=this.layers.length>0)}async fadeTo(t="black",i=1e3){t=h.color.from(t);const s=this.startDialog();let e=0,r=0;for(;r<i;)r+=32,await this.loop.pause(32)&&(r=i),e=Math.floor(100*r/i),this.resetDialogBuffer(s),s.mix(t,e),s.render();this.finishDialog()}async alert(t,i,s){var e,r;"number"==typeof t&&(t={duration:t});const o=this.startDialog();s&&(i=h.text.apply(i,s));let n=t.padX||2,a=t.padY||1;t.title&&(a=Math.max(a,2));let l=[i];i.includes("\n")&&(l=i.split("\n"));const u=l.reduce(((t,i)=>Math.max(t,h.text.length(i))),0)+2*n;let d=u+2*n;t.width&&t.width>0&&(d=t.width,t.width<u&&(l=h.text.splitIntoLines(i,t.width-2*n)));let c=Math.max(l.length+2*a,t.height||0);const f=null!==(e=t.x)&&void 0!==e?e:Math.min(Math.floor((o.width-d)/2)),g=null!==(r=t.y)&&void 0!==r?r:Math.floor((o.height-c)/2),b=h.color.from(t.fg||"white");if(t.borderBg?(o.fillRect(f,g,d,c,0,0,t.borderBg),o.fillRect(f+1,g+1,d-2,c-2,0,0,t.bg||"gray")):o.fillRect(f,g,d,c,0,0,t.bg||"gray"),t.title){let i=f+Math.floor((d-t.title.length)/2);o.drawText(i,g,t.title,t.titleFg||b)}l.forEach(((t,i)=>{o.drawText(f+n,g+a+i,t,b)})),o.render(),t.waitForAck?await this.loop.waitForAck():await this.loop.pause(t.duration||3e4),this.finishDialog()}async confirm(...t){let i,s,e=null;t.length<=2?(i={},s=t[0],e=t[1]||null):(i=t[0],s=t[1],e=t[2]||null),e&&(s=h.text.apply(s,e)),i.allowCancel=i.allowCancel||!!i.cancel;const r=this.startDialog();r.mix("black",50);const o=i.ok||"OK",n=i.cancel||"Cancel",a=Math.max(s.length,o.length+4+n.length),l=Math.floor((this.canvas.width-a-4)/2)-2,u=Math.floor(this.canvas.height/2)-1;let d;for(r.fillRect(l,u,a+4,5," ","black",i.bg||"dark_gray"),r.drawText(l+2,u+1,s,i.fg||"white"),r.drawText(l+2,u+3,o,i.buttonFg||"white",i.buttonBg),i.allowCancel&&r.drawText(l+a+4-n.length-2,u+3,n,i.buttonFg||"white",i.buttonBg),r.render();void 0===d;){const t=await this.loop.nextEvent(1e3);t&&await h.io.dispatchEvent(t,{enter(){d=!0},escape(){i.allowCancel&&(d=!1)},mousemove(){let s=t.x<l+o.length+2,e=t.x>l+a+4-n.length-4;(t.x<l||t.x>l+a+4)&&(s=!1,e=!1),t.y!=u+3&&(s=!1,e=!1),r.drawText(l+2,u+3,o,s?h.colors.teal:h.colors.white),i.allowCancel&&r.drawText(l+a+4-n.length-2,u+3,n,e?h.colors.teal:h.colors.white),r.render()},click(){t.x<l||t.x>l+a+4||t.y<u||t.y>u+5||(d=t.x<l+Math.floor(a/2)+2)}})}return this.finishDialog(),d}async getInputAt(t,i,s,e={}){let r=e.numbersOnly||!1;const o=r?["0","9"]:[" ","~"],n=this.startDialog();s=Math.min(s,n.width-t);const a=e.minLength||1;let l=e.default||"",u=h.text.length(l);const d=h.color.from(e.fg||"white"),c=h.color.from(e.bg||"dark_gray"),f=h.color.from(e.errorFg||"red"),g=e.hintFg?h.color.from(e.hintFg):"gray";function b(t){if(r){const i=Number.parseInt(t);return!(void 0!==e.min&&i<e.min)&&(!(void 0!==e.max&&i>e.max)&&i>0)}return t.length>=a}let w;do{if(n.fillRect(t,i,s,1," ",d,c),!l.length&&e.hint&&e.hint.length)n.drawText(t,i,e.hint,g);else{const s=b(l)?d:f;n.drawText(t,i,l,s)}if(n.render(),w=await this.loop.nextKeyPress(-1),w&&w.key&&(("Delete"==w.key||"Backspace"==w.key)&&u>0?(n.draw(t+u-1,i," ",d),u--,l=h.text.spliceRaw(l,u,1)):w.key.length>1||w.key>=o[0]&&w.key<=o[1]&&u<s&&(l+=w.key,u++),"Escape"==w.key))return this.finishDialog(),""}while(!b(l)||!w||"Enter"!=w.key);return this.finishDialog(),l}async inputBox(t,i,s){var e;let r;i&&(r=h.text.apply(i,s));const o=null===(e=t.allowCancel)||void 0===e||e,n=t.bg||"black",a=this.startDialog();a.mix("black",50);const l="Cancel",u=Math.max(r.length,"OK".length+4+l.length),d=Math.floor((a.width-u-4)/2)-2,c=Math.floor(a.height/2)-1;a.fillRect(d,c,u+4,6," ","black",n),a.drawText(d+2,c+1,r),a.fillRect(d+2,c+2,u-4,1," ","gray","gray"),a.drawText(d+2,c+4,"OK"),o&&a.drawText(d+u+4-l.length-2,c+4,l),a.render();const f=await this.getInputAt(d+2,c+2,u-4,t);return this.finishDialog(),f}},t.Viewport=class{constructor(t){this.center=!1,this.snap=!1,this.filter=null,this.offsetX=0,this.offsetY=0,this.lockX=!1,this.lockY=!1,this._follow=null,this.ui=t.ui,this.snap=t.snap||!1,this.bounds=new h.xy.Bounds(t.x,t.y,t.width,t.height),this.filter=t.filter||null,t.lock?(this.lockX=!0,this.lockY=!0):(t.lockX&&(this.lockX=!0),t.lockY&&(this.lockY=!0))}get follow(){return this._follow}set follow(t){this.center=!!t,t&&(this.offsetX=t.x-this.halfWidth(),this.offsetY=t.y-this.halfHeight(),this.centerOn(t.x,t.y,t.map)),this._follow=t}toMapX(t){return t+this.offsetX-this.bounds.x}toMapY(t){return t+this.offsetY-this.bounds.y}toInnerX(t){return t-this.bounds.x}toInnerY(t){return t-this.bounds.y}contains(t){return this.bounds.contains(t.x,t.y)}halfWidth(){return Math.floor(this.bounds.width/2)}halfHeight(){return Math.floor(this.bounds.height/2)}centerOn(t,i,s){this.center=!0,this.updateOffset({x:t,y:i},s)}updateOffset(t,i){const s=i||this.bounds;if(t&&h.xy.contains(s,t.x,t.y))if(this.snap){let i=this.offsetX,e=this.offsetX+this.bounds.width,h=this.offsetY,r=this.offsetY+this.bounds.height;(t.x<i||t.x>e)&&(i=this.offsetX=t.x-this.halfWidth(),e=i+this.bounds.width),(t.y<h||t.y>r)&&(h=this.offsetY=t.y-this.halfHeight(),r=h+this.bounds.height);const o=Math.floor(this.bounds.width/5),n=Math.floor(this.bounds.height/5),a=Math.floor(this.bounds.width/3);i+o>=t.x?this.offsetX=Math.max(0,t.x+a-this.bounds.width):e-o<=t.x&&(this.offsetX=Math.min(t.x-a,s.width-this.bounds.width));const l=Math.floor(this.bounds.height/3);h+n>=t.y?this.offsetY=Math.max(0,t.y+l-this.bounds.height):r-n<=t.y&&(this.offsetY=Math.min(t.y-l,s.height-this.bounds.height))}else this.center?(this.offsetX=t.x-this.halfWidth(),this.offsetY=t.y-this.halfHeight()):(this.offsetX=t.x,this.offsetY=t.y);this.lockX&&i&&(this.offsetX=h.clamp(this.offsetX,0,i.width-this.bounds.width)),this.lockY&&i&&(this.offsetY=h.clamp(this.offsetY,0,i.height-this.bounds.height))}drawFor(t){if(!t.map)throw new Error("No map!");return this.draw(t.memory||t.map,t.fov)}draw(t,i){if(!t){if(!this._follow)throw new Error("Either map or follow must be set.");return this.drawFor(this._follow)}this.updateOffset(this._follow,t);const s=new h.sprite.Mixer;for(let e=0;e<this.bounds.width;++e)for(let h=0;h<this.bounds.height;++h){const r=e+this.offsetX,o=h+this.offsetY;if(t.hasXY(r,o)){const e=t.cell(r,o);t.drawer.drawCell(s,e,i)}else s.blackOut();this.filter&&this.filter(s,r,o,t),this.ui.buffer.drawSprite(e+this.bounds.x,h+this.bounds.y,s)}return!0}},t.showDropDown=f,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-ui.min.js.map
