{"version":3,"file":"gw-ui.min.js","sources":["../js/widget/widget.js","../js/widget/text.js","../js/widget/button.js","../js/widget/input.js","../js/widget/table.js","../js/widget/dialog.js","../js/flavor.js","../js/sidebar.js","../js/menu.js","../js/widget/box.js","../js/widget/list.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nexport class Widget {\n    constructor(id, opts) {\n        this.active = false;\n        this.hovered = false;\n        this.tabStop = false;\n        this.depth = 0;\n        this.fg = 0xfff;\n        this.bg = -1;\n        this.activeFg = 0xfff;\n        this.activeBg = -1;\n        this.hoverFg = 0xfff;\n        this.hoverBg = -1;\n        this.text = '';\n        this.align = 'left';\n        this.valign = 'middle';\n        this.bounds = new GWU.xy.Bounds(-1, -1, -1, -1); // nothing set\n        this.id = id;\n        if (opts)\n            this.init(opts);\n        this.reset();\n    }\n    init(opts) {\n        if (opts.x !== undefined)\n            this.bounds.x = opts.x;\n        if (opts.y !== undefined)\n            this.bounds.y = opts.y;\n        if (opts.width !== undefined)\n            this.bounds.width = opts.width;\n        if (opts.height !== undefined)\n            this.bounds.height = opts.height;\n        if (opts.depth !== undefined)\n            this.depth = opts.depth;\n        if (opts.text) {\n            this.text = opts.text;\n            if (this.bounds.width <= 0)\n                this.bounds.width = opts.text.length;\n            if (this.bounds.height <= 0)\n                this.bounds.height = 1;\n        }\n        if (this.bounds.height <= 0)\n            this.bounds.height = 1;\n        if (opts.fg !== undefined) {\n            this.fg = opts.fg;\n            this.activeFg = opts.fg;\n            this.hoverFg = opts.fg;\n        }\n        if (opts.bg !== undefined) {\n            this.bg = opts.bg;\n            this.activeBg = opts.bg;\n            this.hoverBg = opts.bg;\n        }\n        if (opts.activeFg !== undefined) {\n            this.activeFg = opts.activeFg;\n            this.hoverFg = opts.activeFg;\n        }\n        if (opts.activeBg !== undefined) {\n            this.activeBg = opts.activeBg;\n            this.hoverBg = opts.activeBg;\n        }\n        if (opts.hoverFg !== undefined)\n            this.hoverFg = opts.hoverFg;\n        if (opts.hoverBg !== undefined)\n            this.hoverBg = opts.hoverBg;\n        if (opts.tabStop !== undefined)\n            this.tabStop = opts.tabStop;\n        this.action = opts.action || this.id;\n    }\n    reset() { }\n    activate(_reverse = false) {\n        this.active = true;\n    }\n    deactivate() {\n        this.active = false;\n    }\n    contains(x, y) {\n        if (arguments.length == 1)\n            return this.bounds.contains(x);\n        return this.bounds.contains(x, y);\n    }\n    // EVENTS\n    // returns true if mouse is over this widget\n    mousemove(e, _dialog) {\n        this.hovered = this.contains(e);\n        return this.hovered;\n    }\n    tick(_e, _dialog) { }\n    // returns true if click is handled by this widget (stopPropagation)\n    click(_e, _dialog) {\n        return false;\n    }\n    // returns true if key is used by widget and you want to stopPropagation\n    keypress(_e, _dialog) {\n        return false;\n    }\n    // returns true if key is used by widget and you want to stopPropagation\n    dir(_e, _dialog) {\n        return false;\n    }\n    // DRAW\n    draw(buffer) {\n        const fg = this.active\n            ? this.activeFg\n            : this.hovered\n                ? this.hoverFg\n                : this.fg;\n        const bg = this.active\n            ? this.activeBg\n            : this.hovered\n                ? this.hoverBg\n                : this.bg;\n        const textLen = GWU.text.length(this.text);\n        if (this.bounds.width > textLen || this.bounds.height > 1) {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', fg, bg);\n        }\n        let x = this.bounds.x;\n        if (this.align == 'center') {\n            x += Math.floor((this.bounds.width - textLen) / 2);\n        }\n        else if (this.align == 'right') {\n            x += this.bounds.width - textLen;\n        }\n        let y = this.bounds.y; // 'top'\n        if (this.bounds.height > 1) {\n            if (this.valign == 'middle') {\n                y += Math.floor(this.bounds.height / 2);\n            }\n            else if (this.valign == 'bottom') {\n                y += this.bounds.height - 1;\n            }\n        }\n        buffer.drawText(x, y, this.text, fg, bg);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Text extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        // if (!opts.text)\n        //     throw new Error(\n        //         'Must have text value in config for Text widget - ' + this.id\n        //     );\n        this.text = opts.text || '';\n        if (opts.wrap) {\n            this.wrap = true;\n            opts.width = opts.wrap;\n            this.lines = GWU.text.splitIntoLines(this.text, \n            // @ts-ignore\n            opts.width);\n        }\n        else {\n            const textLen = GWU.text.length(this.text);\n            opts.width = opts.width || textLen || 10;\n            if (opts.width < textLen) {\n                opts.text = GWU.text.truncate(this.text, opts.width);\n            }\n            this.lines = [this.text];\n        }\n        opts.height = Math.max(this.lines.length, opts.height || 1);\n        super.init(opts);\n    }\n    setText(text) {\n        this.text = text;\n        if (this.wrap) {\n            this.lines = GWU.text.splitIntoLines(this.text, this.bounds.width);\n        }\n        else {\n            const textLen = GWU.text.length(this.text);\n            if (textLen > this.bounds.width) {\n                this.text = GWU.text.truncate(this.text, this.bounds.width);\n            }\n            this.lines = [this.text];\n        }\n    }\n    // TODO - get text() {}, set text(v:string) { // do lines stuff }\n    draw(buffer) {\n        const fg = this.active ? this.activeFg : this.fg;\n        const bg = this.active ? this.activeBg : this.bg;\n        this.lines.forEach((line, i) => {\n            buffer.drawText(this.bounds.x, this.bounds.y + i, line, fg, bg, this.bounds.width);\n        });\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Button extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        if (!opts.text)\n            throw new Error('Must have text value in config for Button widget - ' + this.id);\n        opts.tabStop = GWU.first(opts.tabStop, true); // Can receive input (Enter)\n        super.init(opts);\n    }\n    async click(ev, dialog) {\n        if (!this.contains(ev))\n            return false;\n        await dialog.fireAction(this.action, this);\n        return true;\n    }\n    async keypress(ev, dialog) {\n        if (!ev.key)\n            return false;\n        if (ev.key === 'Enter') {\n            await dialog.fireAction(this.action, this);\n            return true;\n        }\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Input extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        this.minLength = opts.minLength || 1;\n        if (!opts.width) {\n            opts.width = Math.max(this.minLength, 10);\n        }\n        opts.tabStop = GWU.first(opts.tabStop, true); // Need to receive input\n        super.init(opts);\n        this.default = opts.default || '';\n        this.errorFg = opts.errorFg || this.fg;\n        this.hint = opts.hint || '';\n        this.hintFg = opts.hintFg || this.errorFg;\n        this.numbersOnly = opts.numbersOnly || false;\n        this.min = GWU.first(opts.min, Number.MIN_SAFE_INTEGER);\n        this.max = GWU.first(opts.max, Number.MAX_SAFE_INTEGER);\n        if (this.bounds.width <= 0) {\n            if (this.hint)\n                this.bounds.width = this.hint.length;\n            if (this.default)\n                this.bounds.width = this.default.length;\n        }\n        if (this.bounds.height <= 0) {\n            this.bounds.height = 1;\n        }\n        this.reset();\n    }\n    reset() {\n        this.text = this.default;\n    }\n    isValid() {\n        if (this.numbersOnly) {\n            const val = Number.parseInt(this.text);\n            if (this.min !== undefined && val < this.min)\n                return false;\n            if (this.max !== undefined && val > this.max)\n                return false;\n            return val > 0;\n        }\n        return this.text.length >= this.minLength;\n    }\n    get value() {\n        if (this.numbersOnly)\n            return Number.parseInt(this.text);\n        return this.text;\n    }\n    keypress(ev, dialog) {\n        const textEntryBounds = this.numbersOnly ? ['0', '9'] : [' ', '~'];\n        if (!ev.key)\n            return false;\n        if (ev.key === 'Enter' && this.isValid()) {\n            const r = dialog.fireAction(this.action, this);\n            if (r)\n                return r.then(() => true);\n            return true;\n        }\n        if (ev.key == 'Delete' || ev.key == 'Backspace') {\n            if (this.text.length) {\n                this.text = GWU.text.spliceRaw(this.text, this.text.length - 1, 1);\n            }\n            return true;\n        }\n        else if (ev.key.length > 1) {\n            // ignore other special keys...\n            return false;\n        }\n        // eat/use all other keys\n        if (ev.key >= textEntryBounds[0] && ev.key <= textEntryBounds[1]) {\n            // allow only permitted input\n            if (this.text.length < this.bounds.width) {\n                this.text += ev.key;\n            }\n        }\n        return true;\n    }\n    draw(buffer) {\n        const x = this.bounds.x;\n        const y = this.bounds.y;\n        const fg = this.active\n            ? this.activeFg\n            : this.hovered\n                ? this.hoverFg\n                : this.fg;\n        const bg = this.active\n            ? this.activeBg\n            : this.hovered\n                ? this.hoverBg\n                : this.bg;\n        buffer.fillRect(x, y, this.bounds.width, 1, ' ', fg, bg);\n        if (!this.text.length && this.hint && this.hint.length) {\n            buffer.drawText(x, y, this.hint, this.hintFg);\n        }\n        else {\n            const color = this.isValid() ? fg : this.errorFg;\n            buffer.drawText(x, y, this.text, color);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Column {\n    constructor(opts) {\n        this.active = false;\n        this.hovered = false;\n        this.fg = null;\n        this.bg = null;\n        this.activeFg = null;\n        this.activeBg = null;\n        this.hoverFg = null;\n        this.hoverBg = null;\n        this.align = 'left';\n        this.header = '';\n        this.empty = '';\n        this._value = GWU.IDENTITY;\n        // align: Widget.Align = 'left';\n        // valign: Widget.VAlign = 'middle';\n        // hover: HoverType = 'cell';\n        this.x = -1;\n        this.width = -1;\n        this.index = -1;\n        GWU.object.assignOmitting('value', this, opts);\n        if (this.width <= 0) {\n            this.width = this.header.length || 1;\n        }\n        if (typeof opts.value === 'string') {\n            this._value = GWU.text.compile(opts.value);\n        }\n        else {\n            this._value = opts.value || GWU.IDENTITY;\n        }\n        if (opts.align)\n            this.align = opts.align;\n    }\n    value(data, index) {\n        const v = this._value(data, index);\n        return GWU.text.truncate(v, this.width);\n    }\n}\nexport class Table extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n        this.data = null;\n        this.selectedColumn = null;\n        this.selectedIndex = -1;\n    }\n    init(opts) {\n        if (!opts.height)\n            throw new Error('Height is required.');\n        if (!opts.columns || opts.columns.length == 0)\n            throw new Error('Must have at least 1 column.');\n        opts.tabStop = GWU.first(opts.tabStop, true);\n        super.init(opts);\n        this.headers = GWU.first(opts.headers, true);\n        this.letters = GWU.first(opts.letters, true);\n        this.columns = [];\n        this.hoverType = opts.hover || 'row';\n        this.wrapColumns = GWU.first(opts.wrapColumns, opts.wrap, true);\n        this.wrapRows = GWU.first(opts.wrapRows, opts.wrap, true);\n        this.headerFg = opts.headerFg || this.fg;\n        this.headerBg = opts.headerBg || this.bg;\n        let columnWidth = 0;\n        if (opts.letters) {\n            this.columns.push(new Column({\n                width: 2,\n                value: (_data, index) => {\n                    const letter = String.fromCharCode(97 + index);\n                    return letter + ')';\n                },\n            }));\n            columnWidth += 2;\n        }\n        if (opts.columns) {\n            opts.columns.forEach((c) => {\n                const col = new Column(c);\n                this.columns.push(col);\n                columnWidth += col.width;\n            });\n        }\n        this.columns.forEach((c, i) => (c.index = i));\n        // scrolling?  paging?  fixed columns/headers?\n        this.bounds.width =\n            this.bounds.width > 0 ? this.bounds.width : columnWidth;\n    }\n    setData(data) {\n        this.data = data;\n        this.selectedIndex = -1;\n    }\n    selectRow(index) {\n        if (!this.data)\n            return false;\n        const len = Array.isArray(this.data)\n            ? this.data.length\n            : GWU.list.length(this.data);\n        if (index >= len)\n            return false;\n        if (index < -1)\n            return false;\n        this.selectedIndex = index;\n        return true;\n    }\n    selectNextRow(wrap = true) {\n        if (!this.data)\n            return -1;\n        const len = Array.isArray(this.data)\n            ? this.data.length\n            : GWU.list.length(this.data);\n        this.selectedIndex = GWU.nextIndex(this.selectedIndex, len, wrap);\n        if (this.selectedIndex > -1 && !this.selectedColumn) {\n            this.selectedColumn = this.columns[0];\n        }\n        return this.selectedIndex;\n    }\n    selectPrevRow(wrap = true) {\n        if (!this.data)\n            return -1;\n        const len = Array.isArray(this.data)\n            ? this.data.length\n            : GWU.list.length(this.data);\n        this.selectedIndex = GWU.prevIndex(this.selectedIndex, len, wrap);\n        if (this.selectedIndex > -1 && !this.selectedColumn) {\n            this.selectedColumn = this.columns[0];\n        }\n        return this.selectedIndex;\n    }\n    selectNextColumn(wrap = true) {\n        if (!this.selectedColumn) {\n            this.selectedColumn = this.columns[0];\n        }\n        else {\n            let index = GWU.nextIndex(this.selectedColumn.index, this.columns.length, wrap);\n            this.selectedColumn = this.columns[index] || null;\n        }\n        if (this.selectedColumn && this.selectedIndex < 0 && this.data) {\n            this.selectedIndex = 0;\n        }\n        return this.selectedColumn;\n    }\n    selectPrevColumn(wrap = true) {\n        if (!this.selectedColumn) {\n            this.selectedColumn = this.columns[this.columns.length - 1]; // last column\n        }\n        else {\n            let index = GWU.prevIndex(this.selectedColumn.index, this.columns.length, wrap);\n            this.selectedColumn = this.columns[index] || null;\n        }\n        if (this.selectedColumn && this.selectedIndex < 0 && this.data) {\n            this.selectedIndex = 0;\n        }\n        return this.selectedColumn;\n    }\n    get selectedData() {\n        if (!this.data)\n            return null;\n        if (Array.isArray(this.data)) {\n            return this.data[this.selectedIndex] || null;\n        }\n        else {\n            return GWU.list.at(this.data, this.selectedIndex);\n        }\n    }\n    draw(buffer) {\n        const b = this.bounds;\n        buffer.fillRect(b.x, b.y, b.width, b.height, ' ', this.bg, this.bg);\n        let x = b.x;\n        this.columns.forEach((col) => {\n            this.drawColumn(buffer, col, x);\n            x += col.width;\n        });\n    }\n    drawColumn(buffer, column, x) {\n        let y = this.bounds.y;\n        if (column.header) {\n            buffer.fillRect(x, y, column.width, 1, ' ', this.headerFg, this.headerBg);\n            buffer.drawText(x, y, column.header, this.headerFg, this.headerBg, column.width, column.align);\n            ++y;\n        }\n        if (!this.data)\n            return;\n        if (Array.isArray(this.data)) {\n            this.data.forEach((item, index) => {\n                this.drawCell(buffer, column, item, index, x, y);\n                ++y;\n            });\n        }\n        else {\n            GWU.list.forEach(this.data, (item, index) => {\n                this.drawCell(buffer, column, item, index, x, y);\n                ++y;\n            });\n        }\n    }\n    drawCell(buffer, column, data, index, x, y) {\n        if (y > this.bounds.bottom)\n            return;\n        let text = column._value(data, index);\n        if (text.length == 0) {\n            text = column.empty;\n        }\n        // pick color...\n        let fg = this.fg;\n        let bg = this.bg;\n        if (this.hoverType === 'row') {\n            if (index === this.selectedIndex) {\n                fg = this.hoverFg;\n                bg = this.hoverBg;\n            }\n        }\n        else if (this.hoverType === 'column') {\n            if (column === this.selectedColumn) {\n                fg = this.hoverFg;\n                bg = this.hoverBg;\n            }\n        }\n        else if (this.hoverType === 'cell') {\n            if (column === this.selectedColumn &&\n                index === this.selectedIndex) {\n                fg = this.hoverFg;\n                bg = this.hoverBg;\n            }\n        }\n        buffer.fillRect(x, y, column.width, 1, ' ', bg, bg);\n        buffer.drawText(x, y, text, fg, bg, column.width, column.align);\n    }\n    async mousemove(e, dialog) {\n        if (!super.mousemove(e, dialog)) {\n            return false;\n        }\n        const oldColumn = this.selectedColumn;\n        const oldIndex = this.selectedIndex;\n        let x = e.x - this.bounds.x;\n        const column = (this.selectedColumn =\n            this.columns.find((c) => {\n                if (c.width >= x)\n                    return true;\n                x -= c.width;\n                return false;\n            }) || null);\n        let index = -1;\n        if (this.data) {\n            index = e.y - this.bounds.y - (this.headers ? 1 : 0);\n            if (Array.isArray(this.data)) {\n                if (index >= this.data.length)\n                    index = -1;\n            }\n        }\n        this.selectedIndex = index;\n        if (oldColumn !== column || oldIndex !== index) {\n            dialog.fireAction(this.id + '_HOVER', this);\n            dialog.requestRedraw();\n        }\n        return true;\n    }\n    dir(e) {\n        if (!e.dir)\n            return false;\n        if (e.dir[0] > 0) {\n            this.selectNextColumn(this.wrapColumns);\n        }\n        else if (e.dir[0] < 0) {\n            this.selectPrevColumn(this.wrapColumns);\n        }\n        if (e.dir[1] > 0) {\n            this.selectNextRow(this.wrapRows);\n        }\n        else if (e.dir[1] < 0) {\n            this.selectPrevRow(this.wrapRows);\n        }\n        return true;\n    }\n}\nexport function makeTable(id, opts) {\n    return new Table(id, opts);\n}\n","import * as GWU from 'gw-utils';\nexport class Dialog {\n    constructor(ui, opts) {\n        this.title = '';\n        this.titleFg = 0xfff;\n        this.bg = 0x999;\n        this.borderBg = 0x999;\n        this.widgets = [];\n        this.eventHandlers = {};\n        this._activeWidget = null;\n        this.result = null;\n        this.done = false;\n        this.timers = {};\n        this.needsRedraw = true;\n        this.ui = ui;\n        this.id = 'DIALOG';\n        this.bounds = new GWU.xy.Bounds(-1, -1, 0, 0);\n        if (opts)\n            this.init(opts);\n    }\n    init(opts) {\n        if (opts.id)\n            this.id = opts.id;\n        if (opts.x !== undefined)\n            this.bounds.x = opts.x;\n        if (opts.y !== undefined)\n            this.bounds.y = opts.y;\n        if (opts.height !== undefined)\n            this.bounds.height = opts.height;\n        if (opts.width !== undefined)\n            this.bounds.width = opts.width;\n        if (opts.title)\n            this.title = opts.title;\n        if (opts.titleFg)\n            this.titleFg = opts.titleFg;\n        if (opts.bg) {\n            this.bg = opts.bg;\n            this.borderBg = opts.bg;\n        }\n        if (opts.borderBg) {\n            this.borderBg = opts.borderBg;\n        }\n        if (opts.widgets) {\n            opts.widgets.forEach((w) => this.widgets.push(w));\n        }\n        this.widgets.sort((a, b) => (a.depth < b.depth ? -1 : 1));\n    }\n    get activeWidget() {\n        return this._activeWidget;\n    }\n    setActiveWidget(w, reverse = false) {\n        if (w === this._activeWidget)\n            return;\n        if (this._activeWidget) {\n            this._activeWidget.deactivate();\n        }\n        this._activeWidget = w;\n        if (this._activeWidget) {\n            this._activeWidget.activate(reverse);\n        }\n    }\n    contains(e) {\n        return this.bounds.contains(e);\n    }\n    requestRedraw() {\n        this.needsRedraw = true;\n    }\n    setTimeout(action, time) {\n        this.timers[action] = time;\n    }\n    clearTimeout(action) {\n        delete this.timers[action];\n    }\n    async fireAction(action, widget) {\n        const handler = this.eventHandlers[action];\n        if (handler) {\n            await handler(action, this, widget);\n        }\n    }\n    // Multiple calls result in adding more handlers\n    setEventHandlers(map) {\n        Object.assign(this.eventHandlers, map);\n    }\n    async show() {\n        this.done = false;\n        // reset any temp data...\n        this.widgets.forEach((w) => w.reset());\n        // first tabStop is the starting active Widget\n        this.setActiveWidget(this.widgets.find((w) => w.tabStop) || null);\n        // start dialog\n        const buffer = this.ui.startLayer();\n        // run input loop\n        await this.ui.loop.run({\n            keypress: this.keypress.bind(this),\n            dir: this.dir.bind(this),\n            mousemove: this.mousemove.bind(this),\n            click: this.click.bind(this),\n            tick: this.tick.bind(this),\n            draw: () => {\n                this.draw(buffer);\n                buffer.render();\n            },\n        }, 100);\n        // stop dialog\n        this.ui.finishLayer();\n        return this.result;\n    }\n    close(returnValue) {\n        this.result = returnValue;\n        this.done = true;\n    }\n    widgetAt(x, y) {\n        return this.widgets.find((w) => w.contains(x, y)) || null;\n    }\n    getWidget(id) {\n        return this.widgets.find((w) => w.id === id) || null;\n    }\n    nextTabstop() {\n        if (!this.activeWidget) {\n            this.setActiveWidget(this.widgets.find((w) => w.tabStop) || null);\n            return !!this.activeWidget;\n        }\n        const next = GWU.arrayNext(this.widgets, this.activeWidget, (w) => w.tabStop);\n        if (next) {\n            this.setActiveWidget(next);\n            return true;\n        }\n        return false;\n    }\n    prevTabstop() {\n        if (!this.activeWidget) {\n            this.setActiveWidget(this.widgets.find((w) => w.tabStop) || null);\n            return !!this.activeWidget;\n        }\n        const prev = GWU.arrayPrev(this.widgets, this.activeWidget, (w) => w.tabStop);\n        if (prev) {\n            this.setActiveWidget(prev, true);\n            return true;\n        }\n        return false;\n    }\n    async tick(e) {\n        const dt = e.dt;\n        let promises = [];\n        Object.entries(this.timers).forEach(([action, time]) => {\n            time -= dt;\n            if (time <= 0) {\n                delete this.timers[action];\n                promises.push(this.fireAction(action, null));\n            }\n            else {\n                this.timers[action] = time;\n            }\n        });\n        for (let w of this.widgets) {\n            promises.push(w.tick(e, this));\n        }\n        if (promises.length) {\n            return Promise.all(promises).then(() => this.done);\n        }\n        return this.done;\n    }\n    // TODO - async - to allow animations or events on mouseover?\n    async mousemove(e) {\n        // this.setActiveWidget(null);\n        await Promise.all(this.widgets.map(async (w) => {\n            await w.mousemove(e, this);\n            if (w.hovered && w.tabStop) {\n                this.setActiveWidget(w);\n            }\n        }));\n        return this.done;\n    }\n    async click(e) {\n        // this.mousemove(e); // make sure activeWidget is set correctly\n        // if (!this.contains(e)) {\n        //     return false;\n        // }\n        const widget = this.widgetAt(e.x, e.y);\n        let fn = null;\n        if (widget) {\n            if (await widget.click(e, this)) {\n                return this.done;\n            }\n            fn = this.eventHandlers[widget.id];\n        }\n        fn = fn || this.eventHandlers[this.id] || this.eventHandlers.click;\n        if (fn) {\n            await fn(e, this, this.activeWidget);\n        }\n        return this.done;\n    }\n    async keypress(e) {\n        if (!e.key)\n            return false;\n        if (this.activeWidget) {\n            if (await this.activeWidget.keypress(e, this)) {\n                return this.done;\n            }\n        }\n        const fn = this.eventHandlers[e.key] ||\n            this.eventHandlers[e.code] ||\n            this.eventHandlers.keypress;\n        if (fn) {\n            if (await fn(e, this, this.activeWidget)) {\n                return this.done;\n            }\n        }\n        if (e.key === 'Tab') {\n            // Next widget\n            this.nextTabstop();\n            return false; // not done\n        }\n        else if (e.key === 'TAB') {\n            // Prev Widget\n            this.prevTabstop();\n            return false; // not done\n        }\n        return this.done;\n    }\n    async dir(e) {\n        if (this.activeWidget) {\n            if (await this.activeWidget.dir(e, this)) {\n                return this.done;\n            }\n        }\n        const fn = this.eventHandlers.dir || this.eventHandlers.keypress;\n        if (fn) {\n            await fn(e, this, this.activeWidget);\n        }\n        return this.done;\n    }\n    draw(buffer, force = false) {\n        if (!this.needsRedraw && !force)\n            return;\n        this.ui.resetLayerBuffer(buffer);\n        // Draw dialog\n        if (this.borderBg) {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.borderBg, this.borderBg);\n            buffer.fillRect(this.bounds.x + 1, this.bounds.y + 1, this.bounds.width - 2, this.bounds.height - 2, ' ', this.bg, this.bg);\n        }\n        else {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        }\n        if (this.title) {\n            const x = this.bounds.x +\n                Math.floor((this.bounds.width - GWU.text.length(this.title)) / 2);\n            buffer.drawText(x, this.bounds.y, this.title, this.titleFg);\n        }\n        this.widgets.forEach((w) => w.draw(buffer));\n    }\n}\nexport class DialogBuilder {\n    constructor(ui, opts = {}) {\n        this.nextY = 0;\n        this.nextY = 1;\n        this.dialog = new Dialog(ui, opts);\n    }\n    with(widget) {\n        // widget bounds are set relative to the dialog top left,\n        // if we don't get any, help them out\n        // TODO - Get rid of x, y\n        this.addWidget(widget);\n        this.nextY = Math.max(this.nextY, widget.bounds.bottom + 1);\n        return this;\n    }\n    center() {\n        const size = this.dialog.ui.buffer;\n        const bounds = this.dialog.bounds;\n        bounds.x = Math.floor((size.width - bounds.width) / 2);\n        bounds.y = Math.floor((size.height - bounds.height) / 2);\n        return this;\n    }\n    place(x, y) {\n        const bounds = this.dialog.bounds;\n        bounds.x = x;\n        bounds.y = y;\n        return this;\n    }\n    done() {\n        if (this.dialog.bounds.x < 0)\n            this.dialog.bounds.x = 0;\n        if (this.dialog.bounds.y < 0)\n            this.dialog.bounds.y = 0;\n        if (this.dialog.bounds.right > this.dialog.ui.buffer.width)\n            throw new Error('Dialog is off screen!');\n        if (this.dialog.bounds.bottom > this.dialog.ui.buffer.height)\n            throw new Error('Dialog is off screen!');\n        // lock in locations\n        this.dialog.widgets.forEach((w) => {\n            w.bounds.x += this.dialog.bounds.x;\n            w.bounds.y += this.dialog.bounds.y;\n        });\n        return this.dialog;\n    }\n    addWidget(widget) {\n        const dlgBounds = this.dialog.bounds;\n        const x = widget.bounds.x;\n        const y = widget.bounds.y;\n        if (x >= 0) {\n            dlgBounds.width = Math.max(dlgBounds.width, widget.bounds.width + x);\n        }\n        else if (x < 0) {\n            widget.bounds.x = dlgBounds.width - widget.bounds.width + x;\n        }\n        if (y >= 0) {\n            dlgBounds.height = Math.max(dlgBounds.height, widget.bounds.height + y);\n        }\n        else if (y < 0) {\n            widget.bounds.y = dlgBounds.height - widget.bounds.height + y;\n        }\n        this.dialog.widgets.push(widget);\n        return widget;\n    }\n}\nexport function buildDialog(ui, opts = {}) {\n    return new DialogBuilder(ui, opts);\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as Widget from './widget';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor extends Widget.Text {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        opts.fg = opts.fg || 'flavorText';\n        opts.bg = opts.bg || 'black';\n        super.init(opts);\n        this.promptFg = GWU.color.from(opts.promptFg || 'flavorPrompt');\n        this.overflow = opts.overflow || false;\n        this.isPrompt = false;\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        const len = GWU.text.length(this.text);\n        if (len > this.bounds.width) {\n            this.lines = GWU.text.splitIntoLines(this.text, this.bounds.width);\n            if (!this.overflow && this.lines.length > this.bounds.height) {\n                if (this.bounds.height == 1) {\n                    this.text = GWU.text.truncate(this.text, this.bounds.width);\n                    this.lines = [this.text];\n                }\n                else {\n                    this.lines.length = this.bounds.height;\n                }\n            }\n        }\n        else {\n            this.lines = [this.text];\n        }\n        this.isPrompt = false;\n    }\n    clear() {\n        this.text = '';\n        this.lines = [''];\n        this.isPrompt = false;\n    }\n    showPrompt(text) {\n        this.showText(text);\n        this.isPrompt = true;\n    }\n    draw(buffer) {\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        super.draw(buffer);\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nimport * as Widget from './widget';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n        this.sidebarY = -1;\n    }\n    draw(_buffer, _bounds) {\n        return 0;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    draw(buffer, bounds) {\n        return this.actor.drawStatus(buffer, bounds);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    draw(buffer, bounds) {\n        return this.item.drawStatus(buffer, bounds);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(buffer, bounds) {\n        return this.cell.drawStatus(buffer, bounds);\n    }\n}\nexport class Sidebar extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.subject = null;\n        this.highlight = null;\n    }\n    init(opts) {\n        opts.fg = opts.fg || 'purple';\n        opts.bg = opts.bg || 'black';\n        super.init(opts);\n    }\n    reset() {\n        super.reset();\n        this.lastMap = null;\n        this.lastX = -1;\n        this.lastY = -1;\n    }\n    entryAt(e) {\n        return (this.entries.find((entry) => {\n            return entry.sidebarY <= e.y && entry.sidebarY !== -1;\n        }) || null);\n    }\n    mousemove(e, dialog) {\n        super.mousemove(e, dialog);\n        if (this.contains(e)) {\n            return this.highlightRow(e.y);\n        }\n        return this.clearHighlight();\n    }\n    highlightRow(y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        return this.highlight !== last;\n    }\n    clearHighlight() {\n        const result = !!this.highlight;\n        this.highlight = null;\n        return result;\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return entry.priority > 2 || !!this.highlight;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this._addItemEntry(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    update() {\n        if (!this.subject) {\n            throw new Error('Update requires a subject to follow.');\n        }\n        return this.updateFor(this.subject);\n    }\n    updateFor(subject) {\n        return this.updateAt(subject.memory || subject.map, subject.x, subject.y, subject.fov);\n    }\n    updateAt(map, cx, cy, fov) {\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        return true;\n    }\n    draw(buffer) {\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        const drawBounds = this.bounds.clone();\n        let currentEntry;\n        for (let i = 0; i < this.entries.length && drawBounds.height > 0; ++i) {\n            currentEntry = this.entries[i];\n            currentEntry.sidebarY = drawBounds.y;\n            let usedLines = currentEntry.draw(buffer, drawBounds);\n            if (this._isDim(currentEntry)) {\n                buffer.mix(this.bg, 50, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            if (usedLines) {\n                ++usedLines; // skip a space\n                drawBounds.y += usedLines;\n                drawBounds.height -= usedLines;\n            }\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class MenuButton {\n    constructor(text) {\n        this.hovered = false;\n        this.x = 999;\n        this.text = text;\n    }\n    get width() {\n        return this.text.length;\n    }\n}\nexport class ActionButton extends MenuButton {\n    constructor(text, action) {\n        super(text);\n        this.action = action;\n    }\n}\nexport class DropDownButton extends MenuButton {\n    constructor(menu, parent, text, buttons) {\n        super(text);\n        this.buttons = [];\n        this.parent = null;\n        this.menu = menu;\n        this.parent = parent;\n        this.text = text;\n        this.bounds = new GWU.xy.Bounds(0, 0, 0, 0);\n        Object.entries(buttons).forEach(([text, opts]) => {\n            this.addButton(text, opts);\n        });\n    }\n    addButton(text, config) {\n        // if (this.buttons.length >= this.menu.bounds.height - 1) {\n        //     throw new Error('Too many menu options.');\n        // }\n        let button;\n        if (typeof config === 'string') {\n            button = new ActionButton(text, config);\n        }\n        else {\n            button = new DropDownButton(this.menu, this, text, config);\n        }\n        this.buttons.push(button);\n        ++this.bounds.height;\n        this.bounds.width = Math.max(this.bounds.width, text.length + 2);\n    }\n    setBounds(buffer, px, py, pw) {\n        // vertical reveal\n        const right = px + pw;\n        const totalWidth = buffer.width;\n        if (this.bounds.width < totalWidth - right) {\n            this.bounds.x = right;\n        }\n        else if (this.bounds.width < px) {\n            this.bounds.x = px - this.bounds.width;\n        }\n        else {\n            throw new Error('Menu does not fit - too wide.');\n        }\n        const totalHeight = buffer.height;\n        if (this.bounds.height <= totalHeight - py) {\n            this.bounds.y = py;\n        }\n        else if (this.bounds.height < totalHeight) {\n            this.bounds.y = totalHeight - this.bounds.height - 1;\n        }\n        else {\n            throw new Error('Menu does not fit - too tall.');\n        }\n        // this.buttons.forEach((b) => {\n        //     if (b instanceof DropDownButton) {\n        //         b.setBounds(buffer);\n        //     }\n        // });\n    }\n    contains(e) {\n        return this.bounds.contains(e);\n    }\n    buttonAt(e) {\n        const index = e.y - this.bounds.y;\n        return this.buttons[index] || null;\n    }\n    draw(buffer) {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n        const x = this.bounds.x;\n        let y = this.bounds.y;\n        buffer.fillRect(x, y, width, height, 0, 0, this.menu.dropBg);\n        // Now draw the individual buttons...\n        this.buttons.forEach((b) => {\n            buffer.drawText(x + 1, y, b.text, b.hovered ? this.menu.activeFg : this.menu.dropFg, b.hovered ? this.menu.activeBg : this.menu.dropBg);\n            ++y;\n        });\n        if (this.parent) {\n            this.parent.draw(buffer);\n        }\n    }\n}\nexport async function showDropDown(dialog, menu, button) {\n    // Start dialog\n    const ui = dialog.ui;\n    const buffer = ui.startLayer();\n    button.buttons.forEach((b) => (b.hovered = false));\n    button.buttons[0].hovered = true;\n    let activeButton = button;\n    await ui.loop.run({\n        Escape() {\n            return true;\n        },\n        // TODO - Tab\n        Tab() {\n            menu.activeIndex = (menu.activeIndex + 1) % menu.buttons.length;\n            const button = menu.buttons[menu.activeIndex];\n            if (button) {\n                button.hovered = true;\n            }\n            if (activeButton && button instanceof DropDownButton) {\n                activeButton.hovered = false;\n                activeButton = button;\n            }\n            else {\n                activeButton = null; // done.\n            }\n            dialog.requestRedraw();\n            return !activeButton;\n        },\n        // TODO - TAB\n        TAB() {\n            menu.activeIndex =\n                (menu.buttons.length + menu.activeIndex - 1) %\n                    menu.buttons.length;\n            const button = menu.buttons[menu.activeIndex];\n            if (button) {\n                button.hovered = true;\n            }\n            if (activeButton && button instanceof DropDownButton) {\n                activeButton.hovered = false;\n                activeButton = button;\n            }\n            else {\n                activeButton = null; // done.\n            }\n            dialog.requestRedraw();\n            return !activeButton;\n        },\n        mousemove: (e) => {\n            if (!activeButton)\n                return true; // we are done (should not happen)\n            let newActive = activeButton;\n            while (newActive && !newActive.contains(e)) {\n                newActive = newActive.parent;\n            }\n            if (newActive) {\n                activeButton = newActive;\n                const selected = activeButton.buttonAt(e);\n                if (selected) {\n                    activeButton.buttons.forEach((b) => {\n                        b.hovered = false;\n                    });\n                    selected.hovered = true;\n                    if (selected instanceof DropDownButton) {\n                        selected.buttons.forEach((b) => {\n                            b.hovered = false;\n                        });\n                        selected.buttons[0].hovered = true;\n                        selected.setBounds(ui.buffer, activeButton.bounds.x, e.y, activeButton.bounds.width);\n                        activeButton = selected;\n                    }\n                }\n            }\n            else {\n                if (menu.contains(e)) {\n                    if (dialog)\n                        dialog.requestRedraw();\n                    const button = menu.getButtonAt(e.x, e.y);\n                    if (button) {\n                        button.hovered = true;\n                        menu.activeIndex = menu.buttons.indexOf(button);\n                    }\n                    if (button instanceof DropDownButton) {\n                        activeButton.hovered = false;\n                        activeButton = button;\n                    }\n                    else {\n                        activeButton = null; // done.\n                    }\n                    if (dialog)\n                        dialog.requestRedraw();\n                }\n            }\n            return !activeButton; // if no active button we are done (should not happen)\n        },\n        click: async (e) => {\n            if (!activeButton)\n                return true; // we are done (should not happen)\n            if (!activeButton.contains(e)) {\n                menu.clearHighlight();\n                return true; // we are done\n            }\n            const actionButton = activeButton.buttonAt(e);\n            if (!actionButton) {\n                return true; // weird, but we are done.\n            }\n            if (actionButton instanceof ActionButton) {\n                menu.actionButton = actionButton;\n                await dialog.fireAction(actionButton.action, menu);\n                return true;\n            }\n            return false;\n        },\n        draw: () => {\n            if (!activeButton)\n                return;\n            ui.resetLayerBuffer(buffer);\n            activeButton.draw(buffer);\n            menu.draw(buffer);\n            buffer.render();\n        },\n    });\n    ui.finishLayer();\n    menu.clearHighlight();\n}\nexport class Menu extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n        this.activeIndex = -1;\n        this.actionButton = null;\n    }\n    init(opts) {\n        opts.fg = GWU.first(opts.fg, 'black');\n        opts.bg = GWU.first(opts.bg, 'light_gray');\n        opts.height = opts.height || 1;\n        opts.tabStop = GWU.first(opts.tabStop, true);\n        super.init(opts);\n        this.dropFg = GWU.color.from(opts.dropFg || this.fg);\n        this.dropBg = GWU.color.from(opts.dropBg || this.bg);\n        this.buttons = [];\n        this.separator = opts.separator || ' | ';\n        this.lead = opts.lead || ' ';\n        Object.entries(opts.buttons).forEach(([text, opts]) => {\n            this._addButton(text, opts);\n        });\n        if (opts.separator) {\n            this.separator = opts.separator;\n        }\n        if (opts.lead !== undefined) {\n            this.lead = opts.lead ? opts.lead : '';\n        }\n    }\n    activate(reverse = false) {\n        super.activate(reverse);\n        if (this.activeIndex < 0)\n            this.activeIndex = reverse ? this.buttons.length - 1 : 0;\n    }\n    deactivate() {\n        super.deactivate();\n        this.activeIndex = -1;\n    }\n    mousemove(e, dialog) {\n        // turn off all the hovers\n        this.buttons.forEach((b) => {\n            if (b.hovered) {\n                b.hovered = false;\n            }\n        });\n        if (!super.mousemove(e, dialog))\n            return false;\n        // highlight one of them...\n        if (this.bounds.contains(e)) {\n            let hovered = null;\n            this.buttons.forEach((b) => {\n                b.hovered = false;\n                if (b.x < e.x) {\n                    hovered = b;\n                }\n            });\n            if (hovered) {\n                // @ts-ignore\n                hovered.hovered = true;\n                this.activeIndex = this.buttons.indexOf(hovered);\n            }\n            if (dialog)\n                dialog.requestRedraw();\n            return true; // we handled the message\n        }\n        return false;\n    }\n    clearHighlight() {\n        this.buttons.forEach((b) => {\n            b.hovered = false;\n        });\n    }\n    getButtonAt(x, _y) {\n        return GWU.arrayFindRight(this.buttons, (b) => b.x < x) || null;\n    }\n    async click(e, dialog) {\n        if (this.bounds.contains(e)) {\n            // get active button\n            let activeButton = this.getButtonAt(e.x, e.y);\n            if (!activeButton)\n                return false;\n            this.activeIndex = this.buttons.indexOf(activeButton);\n            if (activeButton instanceof DropDownButton) {\n                await showDropDown(dialog, this, activeButton);\n            }\n            else if (activeButton instanceof ActionButton) {\n                this.actionButton = activeButton;\n                await dialog.fireAction(activeButton.action, this);\n            }\n            return true;\n        }\n        return false;\n    }\n    async keypress(e, dialog) {\n        if (this.active) {\n            if (e.key === 'Tab') {\n                ++this.activeIndex;\n                if (this.activeIndex >= this.buttons.length) {\n                    this.deactivate();\n                    return false; // tabbing away from me, need to process in dialog\n                }\n                return true;\n            }\n            else if (e.key === 'TAB') {\n                --this.activeIndex;\n                if (this.activeIndex < 0) {\n                    this.deactivate();\n                    return false; // shift tabbing away from me, need to process in dialog\n                }\n                return true;\n            }\n            else if (e.key === 'Enter') {\n                const activeButton = this.buttons[this.activeIndex];\n                if (activeButton instanceof DropDownButton) {\n                    await showDropDown(dialog, this, activeButton);\n                }\n                else if (activeButton instanceof ActionButton) {\n                    this.actionButton = activeButton;\n                    await dialog.fireAction(activeButton.action, this);\n                }\n                return true;\n            }\n        }\n        return super.keypress(e, dialog);\n    }\n    _addButton(text, config) {\n        const x = this.buttons.reduce((len, button) => len + button.text.length + this.separator.length, this.lead.length + this.bounds.x);\n        if (x + text.length + 2 > this.bounds.width) {\n            throw new Error('Button makes menu too wide :' + text);\n        }\n        let button;\n        if (typeof config === 'string') {\n            button = new ActionButton(text, config);\n        }\n        else {\n            const dropdown = new DropDownButton(this, null, text, config);\n            dropdown.bounds.x = x;\n            if (this.bounds.y) {\n                dropdown.bounds.y = this.bounds.y - dropdown.bounds.height;\n            }\n            else {\n                dropdown.bounds.y = this.bounds.y + 1;\n            }\n            button = dropdown;\n        }\n        button.x = x;\n        this.buttons.push(button);\n    }\n    draw(buffer) {\n        const bg = this.active ? this.activeBg : this.bg;\n        const fg = this.active ? this.activeFg : this.fg;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, 1, 0, bg, bg);\n        let x = this.bounds.x;\n        const y = this.bounds.y;\n        buffer.drawText(x, y, this.lead, fg);\n        this.buttons.forEach((b, i) => {\n            const hovered = i === this.activeIndex;\n            const color = hovered ? this.hoverFg : fg;\n            const bgColor = hovered ? this.hoverBg : bg;\n            buffer.drawText(b.x, y, b.text, color, bgColor);\n            x = b.x + b.text.length;\n            buffer.drawText(x, y, this.separator, fg);\n        });\n        return true;\n    }\n}\n","import * as Widget from './widget';\nexport class Box extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, (() => {\n            if (!opts)\n                return opts;\n            if (opts.depth === undefined)\n                opts.depth = -1; // hid behind other widgets\n            if (opts.title)\n                opts.text = opts.title;\n            return opts;\n        })());\n    }\n    init(opts) {\n        super.init(opts);\n        this.borderBg = opts.borderBg || null;\n    }\n    // EVENTS\n    // box is completely idle\n    mousemove(_e, _dialog) {\n        return false;\n    }\n    // DRAW\n    draw(buffer) {\n        const fg = this.active\n            ? this.activeFg\n            : this.hovered\n                ? this.hoverFg\n                : this.fg;\n        const bg = this.active\n            ? this.activeBg\n            : this.hovered\n                ? this.hoverBg\n                : this.bg;\n        // Draw dialog\n        if (this.borderBg) {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.borderBg, this.borderBg);\n            buffer.fillRect(this.bounds.x + 1, this.bounds.y + 1, this.bounds.width - 2, this.bounds.height - 2, ' ', bg, bg);\n        }\n        else {\n            buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', bg, bg);\n        }\n        if (this.text) {\n            buffer.drawText(this.bounds.x, this.bounds.y, this.text, fg, -1, this.bounds.width, 'center');\n        }\n    }\n}\n","import * as Table from './table';\nexport class List extends Table.Table {\n    constructor(id, opts) {\n        super(id, (() => {\n            // @ts-ignore\n            const tableOpts = opts;\n            tableOpts.columns = [opts];\n            tableOpts.headers = opts.header ? true : false;\n            tableOpts.hover = opts.hover === false ? 'none' : 'row';\n            return tableOpts;\n        })());\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Messages extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n    }\n    init(opts) {\n        opts.x = opts.x || 0;\n        opts.y = opts.y || 0;\n        super.init(opts);\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.length || 40,\n            match: (_x, _y) => {\n                return true;\n            },\n        });\n    }\n    click(e, dialog) {\n        if (!this.contains(e))\n            return false;\n        return this.showArchive(dialog).then(() => true);\n    }\n    draw(buffer) {\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, this.fg);\n            if (confirmed) {\n                buffer.mix(this.bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    async showArchive(dialog) {\n        let reverse, fadePercent = 0;\n        let fastForward;\n        const ui = dialog.ui;\n        // Count the number of lines in the archive.\n        let totalMessageCount = this.cache.length;\n        if (totalMessageCount <= this.bounds.height)\n            return false;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = ui.startLayer();\n        const fg = GWU.color.from(this.fg);\n        totalMessageCount = Math.min(totalMessageCount, isOnTop ? dbuf.height - this.bounds.top : this.bounds.bottom + 1);\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            const dM = reverse ? -1 : 1;\n            const startM = reverse ? totalMessageCount : this.bounds.height;\n            const endM = reverse\n                ? this.bounds.height + dM + 1\n                : totalMessageCount + dM;\n            // console.log(\n            //     `setting up draw - startM=${startM}, endM=${endM}, dM=${dM}`\n            // );\n            for (let currentM = startM; currentM != endM; currentM += dM) {\n                const startY = isOnTop\n                    ? this.bounds.y + currentM - 1\n                    : this.bounds.bottom - currentM + 1;\n                const endY = isOnTop ? this.bounds.y : this.bounds.bottom;\n                const dy = isOnTop ? -1 : 1;\n                ui.resetLayerBuffer(dbuf);\n                // console.log(\n                //     `draw archive - count=${i}, startY=${startY}, endY=${endY}, dy=${dy}`\n                // );\n                dbuf.fillRect(this.bounds.x, Math.min(startY, endY), this.bounds.width, currentM, ' ', this.bg, this.bg);\n                this.cache.forEach((line, _confirmed, j) => {\n                    const y = startY + j * dy;\n                    if (isOnTop) {\n                        if (y < endY)\n                            return;\n                    }\n                    else if (y > endY)\n                        return;\n                    fadePercent = Math.floor((50 * j) / currentM);\n                    const fgColor = fg.clone().mix(this.bg, fadePercent);\n                    dbuf.drawText(this.bounds.x, y, line, fgColor, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward) {\n                    if (await ui.loop.pause(reverse ? 15 : 45)) {\n                        fastForward = true;\n                        currentM = endM - 2 * dM; // skip to the end-1\n                    }\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await ui.loop.waitForAck();\n            }\n        }\n        ui.finishLayer();\n        this.cache.confirmAll();\n        dialog.requestRedraw(); // everything is confirmed\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    get baseBuffer() {\n        return this.layers[this.layers.length - 1] || this.canvas.buffer;\n    }\n    get canvasBuffer() {\n        return this.canvas.buffer;\n    }\n    startLayer() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetLayerBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishLayer() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n    // UTILITY FUNCTIONS\n    async fadeTo(color = 'black', duration = 1000) {\n        color = GWU.color.from(color);\n        const buffer = this.startLayer();\n        let pct = 0;\n        let elapsed = 0;\n        while (elapsed < duration) {\n            elapsed += 32;\n            if (await this.loop.pause(32)) {\n                elapsed = duration;\n            }\n            pct = Math.floor((100 * elapsed) / duration);\n            this.resetLayerBuffer(buffer);\n            buffer.mix(color, pct);\n            buffer.render();\n        }\n        this.finishLayer();\n    }\n    async alert(opts, text, args) {\n        if (typeof opts === 'number') {\n            opts = { duration: opts };\n        }\n        if (args) {\n            text = GWU.text.apply(text, args);\n        }\n        const padX = opts.padX || opts.pad || 1;\n        const padY = opts.padY || opts.pad || 1;\n        opts.width = opts.width || GWU.text.length(text) + 2 * padX;\n        const textOpts = {\n            fg: opts.fg,\n            text,\n            x: padX,\n            y: padY,\n            wrap: opts.width - 2 * padX,\n        };\n        textOpts.text = text;\n        textOpts.wrap = opts.width;\n        const textWidget = new Widget.Text('TEXT', textOpts);\n        opts.height =\n            (opts.title ? 1 : 0) + padY + textWidget.bounds.height + padY;\n        const dlg = Widget.buildDialog(this, opts)\n            .with(textWidget)\n            .center()\n            .done();\n        dlg.setEventHandlers({\n            click: () => dlg.close(true),\n            keypress: () => dlg.close(true),\n            TIMEOUT: () => dlg.close(false),\n        });\n        if (!opts.waitForAck) {\n            dlg.setTimeout('TIMEOUT', opts.duration || 3000);\n        }\n        return await dlg.show();\n    }\n    async confirm(...args) {\n        let opts;\n        let text;\n        let textArgs = null;\n        if (args.length <= 2 && typeof args[0] === 'string') {\n            opts = {};\n            text = args[0];\n            textArgs = args[1] || null;\n        }\n        else {\n            opts = args[0];\n            text = args[1];\n            textArgs = args[2] || null;\n        }\n        if (textArgs) {\n            text = GWU.text.apply(text, textArgs);\n        }\n        const padX = opts.padX || opts.pad || 1;\n        const padY = opts.padY || opts.pad || 1;\n        opts.width =\n            opts.width ||\n                Math.min(Math.floor(this.buffer.width / 2), GWU.text.length(text) + 2 * padX);\n        let textWidth = opts.width - 2 * padX;\n        const textOpts = {\n            fg: opts.fg,\n            text,\n            wrap: textWidth,\n            y: opts.title ? 2 : 1,\n            x: padX,\n        };\n        const textWidget = new Widget.Text('TEXT', textOpts);\n        opts.height =\n            (opts.title ? 1 : 0) + padY + textWidget.bounds.height + 2 + padY;\n        opts.allowCancel = opts.allowCancel !== false;\n        opts.buttons = Object.assign({\n            fg: 'white',\n            activeFg: 'teal',\n            bg: 'dark_gray',\n            activeBg: 'darkest_gray',\n        }, opts.buttons || {});\n        if (typeof opts.ok === 'string') {\n            opts.ok = { text: opts.ok };\n        }\n        if (typeof opts.cancel === 'string') {\n            opts.cancel = { text: opts.cancel };\n        }\n        opts.ok = opts.ok || {};\n        opts.cancel = opts.cancel || {};\n        const okOpts = Object.assign({}, opts.buttons, { text: 'OK', y: -padY, x: padX }, opts.ok);\n        const cancelOpts = Object.assign({}, opts.buttons, { text: 'CANCEL', y: -padY, x: -padX }, opts.cancel);\n        const builder = Widget.buildDialog(this, opts)\n            .with(textWidget)\n            .with(new Widget.Button('OK', okOpts));\n        if (opts.allowCancel) {\n            builder.with(new Widget.Button('CANCEL', cancelOpts));\n        }\n        const dlg = builder.center().done();\n        dlg.setEventHandlers({\n            OK() {\n                dlg.close(true);\n            },\n            CANCEL() {\n                dlg.close(false);\n            },\n            Escape() {\n                dlg.close(false);\n            },\n            Enter() {\n                dlg.close(true);\n            },\n        });\n        return await dlg.show();\n    }\n    async showWidget(widget, keymap = {}) {\n        if (widget.bounds.x < 0) {\n            widget.bounds.x = Math.floor((this.buffer.width - widget.bounds.width) / 2);\n        }\n        if (widget.bounds.y < 0) {\n            widget.bounds.y = Math.floor((this.buffer.height - widget.bounds.height) / 2);\n        }\n        const dlg = new Widget.Dialog(this, {\n            width: widget.bounds.width,\n            height: widget.bounds.height,\n            widgets: [widget],\n            x: widget.bounds.x,\n            y: widget.bounds.y,\n            bg: -1,\n        });\n        keymap.Escape =\n            keymap.Escape ||\n                (() => {\n                    dlg.close(false);\n                });\n        dlg.setEventHandlers(keymap);\n        return await dlg.show();\n    }\n    // assumes you are in a dialog and give the buffer for that dialog\n    async getInputAt(x, y, maxLength, opts = {}) {\n        opts.width = maxLength;\n        opts.x = x;\n        opts.y = y;\n        const widget = new Widget.Input('INPUT', opts);\n        return this.showWidget(widget, {\n            INPUT(_e, dlg) {\n                dlg.close(widget.text);\n            },\n            Escape(_e, dlg) {\n                dlg.close('');\n            },\n        });\n    }\n    async inputBox(opts, prompt, args) {\n        if (args) {\n            prompt = GWU.text.apply(prompt, args);\n        }\n        const padX = opts.padX || opts.pad || 1;\n        const padY = opts.padY || opts.pad || 1;\n        opts.width =\n            opts.width ||\n                Math.min(Math.floor(this.buffer.width / 2), GWU.text.length(prompt) + 2 * padX);\n        let promptWidth = opts.width - 2 * padX;\n        const promptOpts = {\n            fg: opts.fg,\n            text: prompt,\n            wrap: promptWidth,\n            x: padX,\n            y: (opts.title ? 1 : 0) + padY,\n        };\n        const promptWidget = new Widget.Text('TEXT', promptOpts);\n        opts.height =\n            (opts.title ? 1 : 0) +\n                padY +\n                promptWidget.bounds.height +\n                3 +\n                1 +\n                padY;\n        opts.allowCancel = opts.allowCancel !== false;\n        opts.buttons = Object.assign({\n            fg: 'white',\n            activeFg: 'teal',\n            bg: 'dark_gray',\n            activeBg: 'darkest_gray',\n        }, opts.buttons || {});\n        if (typeof opts.ok === 'string') {\n            opts.ok = { text: opts.ok };\n        }\n        if (typeof opts.cancel === 'string') {\n            opts.cancel = { text: opts.cancel };\n        }\n        opts.ok = opts.ok || {};\n        opts.cancel = opts.cancel || {};\n        const okOpts = Object.assign({}, opts.buttons, { text: 'OK', y: -padY, x: padX }, opts.ok);\n        const cancelOpts = Object.assign({}, opts.buttons, { text: 'CANCEL', y: -padY, x: -padX }, opts.cancel);\n        opts.input = opts.input || {};\n        opts.input.width = opts.input.width || promptWidth;\n        opts.input.bg = opts.input.bg || opts.fg;\n        opts.input.fg = opts.input.fg || opts.bg;\n        opts.input.x = padX;\n        opts.input.y = opts.height - 1 - padY - 2;\n        const inputWidget = new Widget.Input('INPUT', opts.input || {});\n        const builder = Widget.buildDialog(this, opts)\n            .with(promptWidget)\n            .with(inputWidget)\n            .with(new Widget.Button('OK', okOpts));\n        if (opts.allowCancel) {\n            builder.with(new Widget.Button('CANCEL', cancelOpts));\n        }\n        const dlg = builder.center().done();\n        dlg.setEventHandlers({\n            OK() {\n                dlg.close(inputWidget.text);\n            },\n            CANCEL() {\n                dlg.close('');\n            },\n            Escape() {\n                dlg.close('');\n            },\n            INPUT() {\n                dlg.close(inputWidget.text);\n            },\n        });\n        return await dlg.show();\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Widget from './widget';\nexport class Viewport extends Widget.Widget {\n    constructor(id, opts) {\n        super(id, opts);\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n    }\n    init(opts) {\n        opts.bg = opts.bg || 'black';\n        opts.x = opts.x || 0;\n        opts.y = opts.y || 0;\n        super.init(opts);\n        this.snap = opts.snap || false;\n        this.center = opts.center || false;\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n    }\n    set lock(v) {\n        this.lockX = v;\n        this.lockY = v;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.center = true;\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.center = false;\n        this.snap = false;\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.memory || subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    draw(buffer) {\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this.bg);\n        if (!this._subject) {\n            return false;\n        }\n        this.updateOffset();\n        const map = this._subject.memory || this._subject.map;\n        const fov = this._subject.fov;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this.bg, this.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["Widget","constructor","id","opts","this","active","hovered","tabStop","depth","fg","bg","activeFg","activeBg","hoverFg","hoverBg","text","align","valign","bounds","GWU","xy","Bounds","init","reset","undefined","x","y","width","height","length","action","activate","_reverse","deactivate","contains","arguments","mousemove","e","_dialog","tick","_e","click","keypress","dir","draw","buffer","textLen","fillRect","Math","floor","drawText","Text","Widget.Widget","super","wrap","lines","splitIntoLines","truncate","max","setText","forEach","line","i","Button","Error","first","async","ev","dialog","fireAction","key","Input","minLength","default","errorFg","hint","hintFg","numbersOnly","min","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","isValid","val","parseInt","value","textEntryBounds","r","then","spliceRaw","color","Column","header","empty","_value","IDENTITY","index","object","assignOmitting","compile","data","v","Table","selectedColumn","selectedIndex","columns","headers","letters","hoverType","hover","wrapColumns","wrapRows","headerFg","headerBg","columnWidth","push","_data","String","fromCharCode","c","col","setData","selectRow","Array","isArray","list","selectNextRow","len","nextIndex","selectPrevRow","prevIndex","selectNextColumn","selectPrevColumn","selectedData","at","b","drawColumn","column","item","drawCell","bottom","oldColumn","oldIndex","find","requestRedraw","Dialog","ui","title","titleFg","borderBg","widgets","eventHandlers","_activeWidget","result","done","timers","needsRedraw","w","sort","a","activeWidget","setActiveWidget","reverse","setTimeout","time","clearTimeout","widget","handler","setEventHandlers","map","Object","assign","startLayer","loop","run","bind","render","finishLayer","close","returnValue","widgetAt","getWidget","nextTabstop","next","arrayNext","prevTabstop","prev","arrayPrev","dt","promises","entries","Promise","all","fn","code","force","resetLayerBuffer","DialogBuilder","nextY","with","addWidget","center","size","place","right","dlgBounds","buildDialog","install","EntryBase","dist","priority","changed","sidebarY","_buffer","_bounds","ActorEntry","actor","drawStatus","ItemEntry","CellEntry","cell","MenuButton","ActionButton","DropDownButton","menu","parent","buttons","addButton","config","button","setBounds","px","py","pw","totalWidth","totalHeight","buttonAt","dropBg","dropFg","showDropDown","activeButton","Escape","Tab","activeIndex","TAB","newActive","selected","getButtonAt","indexOf","clearHighlight","actionButton","Widget.Text","promptFg","from","overflow","isPrompt","showText","capitalize","clear","showPrompt","getFlavorText","fov","buf","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","Table.Table","tableOpts","separator","lead","_addButton","_y","arrayFindRight","reduce","dropdown","bgColor","cache","message","MessageCache","match","_x","showArchive","isOnTop","confirmed","mix","fastForward","fadePercent","totalMessageCount","dbuf","top","dM","startM","endM","currentM","startY","endY","dy","_confirmed","j","fgColor","clone","pause","wrapText","waitForAck","confirmAll","cellCache","lastX","lastY","lastMap","subject","highlight","entryAt","entry","highlightRow","last","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","clearMapFlag","_makeActorEntry","_makeItemEntry","_makeCellEntry","_getPriority","hasCellFlag","Cell","STABLE_MEMORY","_isDim","_addActorEntry","distanceBetween","isPlayer","_addItemEntry","_addCellEntry","findEntries","cx","cy","grid","alloc","eachActor","eachItem","free","update","updateFor","updateAt","memory","drawBounds","currentEntry","usedLines","layers","freeBuffers","inDialog","canvas","baseBuffer","canvasBuffer","base","pop","Buffer","copy","dest","duration","pct","elapsed","args","padX","pad","padY","textOpts","textWidget","dlg","Widget.buildDialog","TIMEOUT","show","textArgs","textWidth","allowCancel","ok","cancel","okOpts","cancelOpts","builder","Widget.Button","OK","CANCEL","Enter","keymap","Widget.Dialog","maxLength","Widget.Input","showWidget","INPUT","prompt","promptWidth","promptOpts","promptWidget","input","inputWidget","offsetX","offsetY","_subject","snap","filter","lock","lockX","lockY","halfWidth","halfHeight","toMapX","toMapY","toInnerX","toInnerY","centerOn","showMap","updateOffset","hasXY","left","edgeX","edgeY","thirdW","thirdH","clamp","blackOutRect","mixer","sprite","Mixer","mapX","mapY","drawer","drawSprite"],"mappings":"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"}