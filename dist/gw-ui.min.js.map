{"version":3,"file":"gw-ui.min.js","sources":["../js/flavor.js","../js/sidebar.js","../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        var _a, _b, _c;\n        this.text = '';\n        this.needsUpdate = false;\n        this.isPrompt = false;\n        this.overflow = false;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.fg = GWU.color.from((_a = opts.fg) !== null && _a !== void 0 ? _a : 'flavorText');\n        this.bg = GWU.color.from((_b = opts.bg) !== null && _b !== void 0 ? _b : 'black');\n        this.promptFg = GWU.color.from((_c = opts.promptFg) !== null && _c !== void 0 ? _c : 'flavorPrompt');\n    }\n    showText(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    clear() {\n        this.text = '';\n        this.needsUpdate = true;\n        this.isPrompt = false;\n        this.draw();\n    }\n    showPrompt(text) {\n        this.text = GWU.text.capitalize(text);\n        this.needsUpdate = true;\n        this.isPrompt = true;\n        this.draw();\n    }\n    draw(force = false) {\n        if (!force && !this.needsUpdate)\n            return false;\n        const buffer = this.ui.buffer;\n        const color = this.isPrompt ? this.fg : this.promptFg;\n        const nextY = buffer.wrapText(this.bounds.x, this.bounds.y, this.bounds.width, this.text, color, this.bg);\n        this.overflow = nextY !== this.bounds.y + 1;\n        this.ui.render();\n        this.needsUpdate = false;\n        return true;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'you see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'you sense';\n        }\n        else if (isRemembered) {\n            intro = 'you remember';\n        }\n        else if (isMapped) {\n            intro = 'you expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(GWM.flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(GWM.flags.Depth.GROUND) || GWM.tile.tiles.NULL;\n        const surfaceTile = cell.depthTile(GWM.flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(GWM.flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(GWM.flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(GWM.flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('§intro§ §text§.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as GWM from 'gw-map';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.changed = false;\n    }\n    draw(_sidebar) { }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    draw(sidebar) {\n        this.actor.drawStatus(sidebar);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    draw(sidebar) {\n        this.item.drawStatus(sidebar);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.cell = cell;\n    }\n    draw(sidebar) {\n        this.cell.drawStatus(sidebar);\n    }\n}\nexport class Sidebar {\n    constructor(opts) {\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.mixer = new GWU.sprite.Mixer();\n        this.currentY = 0;\n        this.currentPriority = -1;\n        this.ui = opts.ui;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'purple');\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasEntityFlag(GWM.flags.Entity.L_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(GWM.flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n    }\n    makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(GWM.flags.Cell.STABLE_MEMORY)\n                ? 3\n                : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    addActor(actor, map, x, y, fov) {\n        const priority = this.getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this.makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    addItem(item, map, x, y, fov) {\n        const priority = this.getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this.makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    addCell(cell, map, x, y, fov) {\n        const priority = this.getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this.makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    findEntries(map, cx, cy, fov) {\n        if (map === this.lastMap && cx === this.lastX && cy === this.lastY)\n            return;\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (done[x][y])\n                return;\n            if (this.addActor(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (done[x][y])\n                return;\n            if (this.addItem(i, map, cx, cy, fov)) {\n                done[x][y] = 1;\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this.addCell(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        GWU.grid.free(done);\n    }\n    clearSidebar() {\n        this.ui.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n    }\n    draw(map, cx, cy, fov) {\n        this.updateCellCache(map);\n        this.findEntries(map, cx, cy, fov);\n        this.clearSidebar();\n        this.currentY = this.bounds.y;\n        this.currentPriority = -1;\n        for (let i = 0; i < this.entries.length && this.currentY < this.bounds.bottom; ++i) {\n            const entry = this.entries[i];\n            this.currentPriority = entry.priority;\n            entry.draw(this);\n            ++this.currentY; // skip a line\n        }\n        this.currentPriority = -1;\n        return true;\n    }\n    drawTitle(cell, title, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this.currentPriority < 3 ? fg : fg.clone().darken(50);\n        this.buffer.drawSprite(this.bounds.x + 1, this.currentY, cell);\n        this.buffer.wrapText(this.bounds.x + 3, this.currentY, this.bounds.width - 3, title, fgColor);\n        ++this.currentY;\n    }\n    drawTextLine(text, fg) {\n        fg = GWU.color.from(fg || this.fg);\n        const fgColor = this.currentPriority < 3 ? fg : fg.clone().darken(50);\n        this.buffer.drawText(this.bounds.x + 3, this.currentY, text, fgColor, this.bounds.width - 3);\n        ++this.currentY;\n    }\n    drawProgressBar(val, max, text, color, bg, fg) {\n        color = GWU.color.from(color || this.fg);\n        bg = GWU.color.from(bg || color.clone().darken(50));\n        fg = GWU.color.from(fg || color.clone().lighten(50));\n        if (this.currentPriority < 3) {\n            bg.darken(50);\n            fg.darken(50);\n            color.darken(50);\n        }\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, this.bounds.width - 1, 1, undefined, undefined, bg);\n        const len = Math.floor(((this.bounds.width - 1) * val) / max);\n        this.buffer.fillRect(this.bounds.x + 1, this.currentY, len, 1, undefined, undefined, color);\n        const title = GWU.text.center(text, this.bounds.width);\n        this.buffer.drawText(this.bounds.x + 1, this.currentY, title, fg, undefined, this.bounds.width - 1 // just in case title is too long\n        );\n        ++this.currentY;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.follow = null;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this.ui = opts.ui;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.updateOffset(map, { x, y });\n    }\n    updateOffset(map, focus) {\n        if (focus && GWU.xy.contains(map, focus.x, focus.y)) {\n            if (this.snap) {\n                const left = this.offsetX;\n                const right = this.offsetX + this.bounds.width;\n                const top = this.offsetY;\n                const bottom = this.offsetY + this.bounds.height;\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= focus.x) {\n                    this.offsetX = Math.max(0, focus.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= focus.x) {\n                    this.offsetX = Math.min(focus.x - thirdW, map.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= focus.y) {\n                    this.offsetY = Math.max(0, focus.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= focus.y) {\n                    this.offsetY = Math.min(focus.y - thirdH, map.height - this.bounds.height);\n                }\n            }\n            else {\n                this.offsetX = focus.x - this.halfWidth();\n                this.offsetY = focus.y - this.halfHeight();\n            }\n        }\n        if (this.lockX) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    draw(map, fov) {\n        if (!map)\n            return false;\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        this.updateOffset(map, this.follow);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(x, y);\n                    map.drawer.drawCell(mixer, cell, fov);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["color","install","EntryBase","constructor","this","dist","priority","changed","draw","_sidebar","ActorEntry","actor","super","sidebar","drawStatus","ItemEntry","item","CellEntry","cell","opts","_a","_b","_c","text","needsUpdate","isPrompt","overflow","ui","bounds","GWU","xy","Bounds","x","y","width","fg","from","bg","promptFg","showText","capitalize","clear","showPrompt","force","buffer","nextY","wrapText","render","getFlavorText","map","fov","buf","object","isAnyKindOfVisible","isDirectlyVisible","isRemembered","isRevealed","isMapped","isMagicMapped","intro","hasActor","actorAt","theItem","hasItem","itemAt","standsInTile","hasTileFlag","GWM","flags","Tile","T_STAND_IN_TILE","needObjectArticle","getFlavor","article","action","groundTile","depthTile","Depth","GROUND","tile","tiles","NULL","surfaceTile","SURFACE","liquidTile","LIQUID","surface","T_BRIDGE","liquid","ground","apply","Math","min","height","cache","message","MessageCache","length","contains","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","loop","pause","waitForAck","finishDialog","confirmAll","cellCache","lastX","lastY","lastMap","entries","mixer","sprite","Mixer","currentY","currentPriority","updateCellCache","hasMapFlag","Map","MAP_SIDEBAR_TILES_CHANGED","forRect","info","hasEntityFlag","Entity","L_LIST_IN_SIDEBAR","push","clearMapFlag","makeActorEntry","makeItemEntry","makeCellEntry","getPriority","hasCellFlag","Cell","STABLE_MEMORY","addActor","entry","distanceBetween","isPlayer","addItem","addCell","findEntries","cx","cy","done","grid","alloc","eachActor","a","eachItem","sort","b","free","clearSidebar","bottom","drawTitle","title","fgColor","darken","drawSprite","drawTextLine","drawText","drawProgressBar","val","max","lighten","undefined","len","center","layers","freeBuffers","inDialog","canvas","Error","base","pop","Buffer","dest","follow","snap","filter","offsetX","offsetY","lockX","lockY","lock","toMapX","toMapY","toInnerX","toInnerY","halfWidth","halfHeight","centerOn","updateOffset","focus","left","right","top","edgeX","edgeY","thirdW","thirdH","clamp","mapX","mapY","hasXY","drawer","drawCell","blackOut"],"mappings":"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"}