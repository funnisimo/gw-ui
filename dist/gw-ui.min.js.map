{"version":3,"file":"gw-ui.min.js","sources":["../js/message.js","../js/ui.js","../js/viewport.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        const buffer = opts.ui.buffer;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, Math.min(opts.width || buffer.width, buffer.width - opts.x), Math.min(opts.height || buffer.height, buffer.height - opts.y));\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: buffer.height,\n        });\n        this.ui = opts.ui;\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.fg = GWU.color.from(opts.fg || 'white');\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    get needsUpdate() {\n        return this.cache.needsUpdate;\n    }\n    get buffer() {\n        return this.ui.buffer;\n    }\n    draw(force = false) {\n        if (!force && !this.cache.needsUpdate)\n            return false;\n        let messageColor;\n        const tempColor = GWU.color.make();\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        this.buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', 0, this.bg);\n        this.cache.forEach((msg, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            messageColor = tempColor;\n            messageColor.copy(this.fg);\n            if (confirmed) {\n                messageColor.mix(this.bg, 50);\n                messageColor.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n            }\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = this.toBufferY(localY);\n            GWU.text.eachChar(msg, (c, color, _bg, j) => {\n                const x = this.toBufferX(j);\n                if (color && messageColor !== color && confirmed) {\n                    color.mix(this.bg, 50);\n                    color.mix(this.bg, (75 * i) / (2 * this.bounds.height));\n                }\n                messageColor = color || tempColor;\n                this.buffer.draw(x, y, c, messageColor, this.bg);\n            });\n            // for (let j = GWU.text.length(msg); j < this.bounds.width; j++) {\n            //     const x = this.toBufferX(j);\n            //     this.buffer.draw(x, y, ' ', this.bg, this.bg);\n            // }\n        });\n        this.cache.needsUpdate = false;\n        return true;\n    }\n    toBufferY(y) {\n        return this.bounds.y + y;\n    }\n    toBufferX(x) {\n        return this.bounds.x + x;\n    }\n    async showArchive() {\n        let reverse, fadePercent, currentMessageCount = 0;\n        let fastForward;\n        // Count the number of lines in the archive.\n        let totalMessageCount = 0;\n        this.cache.forEach(() => ++totalMessageCount);\n        if (totalMessageCount <= this.bounds.height)\n            return;\n        const isOnTop = this.bounds.y < 10;\n        const dbuf = this.ui.startDialog();\n        // Pull-down/pull-up animation:\n        for (reverse = 0; reverse <= 1; reverse++) {\n            fastForward = false;\n            for (currentMessageCount = reverse\n                ? totalMessageCount\n                : this.bounds.height; reverse\n                ? currentMessageCount >= this.bounds.height\n                : currentMessageCount <= totalMessageCount; currentMessageCount += reverse ? -1 : 1) {\n                this.ui.resetDialogBuffer(dbuf);\n                // Print the message archive text to the dbuf.\n                this.cache.forEach((msg, _confirmed, j) => {\n                    if (j >= currentMessageCount || j >= dbuf.height)\n                        return;\n                    const y = isOnTop ? j : dbuf.height - j - 1;\n                    fadePercent = Math.floor((50 * (currentMessageCount - j)) / currentMessageCount);\n                    const fg = this.fg.clone().mix(this.bg, fadePercent);\n                    dbuf.wrapText(this.toBufferX(0), y, this.bounds.width, msg, fg, this.bg);\n                });\n                dbuf.render();\n                if (!fastForward &&\n                    (await this.ui.loop.pause(reverse ? 15 : 45))) {\n                    fastForward = true;\n                    // dequeueEvent();\n                    currentMessageCount = reverse\n                        ? this.bounds.height + 1\n                        : totalMessageCount - 1; // skip to the end\n                }\n            }\n            if (!reverse) {\n                const y = isOnTop ? 0 : dbuf.height - 1;\n                const x = this.bounds.x > 8\n                    ? this.bounds.x - 8 // to left of box\n                    : Math.min(this.bounds.x + this.bounds.width, // just to right of box\n                    this.buffer.width - 8 // But definitely on the screen - overwrite some text if necessary\n                    );\n                dbuf.wrapText(x, y, 8, '--DONE--', this.bg, this.fg);\n                dbuf.render();\n                await this.ui.loop.waitForAck();\n            }\n        }\n        this.ui.finishDialog();\n        this.cache.confirmAll();\n        this.cache.needsUpdate = true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class UI {\n    constructor(opts = {}) {\n        this.layers = [];\n        this.freeBuffers = [];\n        this.inDialog = false;\n        if (!opts.canvas)\n            throw new Error('Need a canvas.');\n        this.canvas = opts.canvas;\n        this.buffer = opts.canvas.buffer;\n        this.loop = opts.loop || GWU.loop;\n    }\n    render() {\n        this.buffer.render();\n    }\n    startDialog() {\n        this.inDialog = true;\n        const base = this.buffer || this.canvas.buffer;\n        this.layers.push(base);\n        this.buffer =\n            this.freeBuffers.pop() || new GWU.canvas.Buffer(this.canvas);\n        // UI_OVERLAY._data.forEach( (c) => c.opacity = 0 );\n        this.buffer.copy(base);\n        return this.buffer;\n    }\n    resetDialogBuffer(dest) {\n        const base = this.layers[this.layers.length - 1] || this.canvas.buffer;\n        dest.copy(base);\n    }\n    finishDialog() {\n        if (!this.inDialog)\n            return;\n        if (this.buffer !== this.canvas.buffer) {\n            this.freeBuffers.push(this.buffer);\n        }\n        this.buffer = this.layers.pop() || this.canvas.buffer;\n        this.buffer.render();\n        this.inDialog = this.layers.length > 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Viewport {\n    constructor(opts) {\n        this.follow = false;\n        this.snap = false;\n        this.filter = null;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.lockX = false;\n        this.lockY = false;\n        this.ui = opts.ui;\n        this.follow = opts.follow || false;\n        this.snap = opts.snap || false;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.filter = opts.filter || null;\n        if (opts.lock) {\n            this.lockX = true;\n            this.lockY = true;\n        }\n        else {\n            if (opts.lockX) {\n                this.lockX = true;\n            }\n            if (opts.lockY) {\n                this.lockY = true;\n            }\n        }\n    }\n    toMapX(x) {\n        return x + this.offsetX;\n    }\n    toMapY(y) {\n        return y + this.offsetY;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    contains(x, y) {\n        return this.bounds.contains(x, y);\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    draw(map, playerX, playerY) {\n        if (!map)\n            return false;\n        // if (!map.hasMapFlag(GWM.flags.Map.MAP_CHANGED)) return false;\n        if (this.follow && playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX - this.halfWidth();\n            this.offsetY = playerY - this.halfHeight();\n        }\n        else if (this.snap &&\n            playerX !== undefined &&\n            playerY !== undefined) {\n            const left = this.offsetX;\n            const right = this.offsetX + this.bounds.width;\n            const top = this.offsetY;\n            const bottom = this.offsetY + this.bounds.height;\n            const edgeX = Math.floor(this.bounds.width / 5);\n            const edgeY = Math.floor(this.bounds.height / 5);\n            const thirdW = Math.floor(this.bounds.width / 3);\n            if (left + edgeX >= playerX) {\n                this.offsetX = Math.max(0, playerX + thirdW - this.bounds.width);\n            }\n            else if (right - edgeX <= playerX) {\n                this.offsetX = Math.min(playerX - thirdW, map.width - this.bounds.width);\n            }\n            const thirdH = Math.floor(this.bounds.height / 3);\n            if (top + edgeY >= playerY) {\n                this.offsetY = Math.max(0, playerY + thirdH - this.bounds.height);\n            }\n            else if (bottom - edgeY <= playerY) {\n                this.offsetY = Math.min(playerY - thirdH, map.height - this.bounds.height);\n            }\n        }\n        else if (playerX !== undefined && playerY !== undefined) {\n            this.offsetX = playerX;\n            this.offsetY = playerY;\n        }\n        if (this.lockX) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    map.getAppearanceAt(mapX, mapY, mixer);\n                }\n                else {\n                    mixer.blackOut();\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                this.ui.buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n}\n"],"names":["constructor","opts","buffer","ui","this","bounds","GWU","xy","Bounds","x","y","Math","min","width","height","cache","message","MessageCache","length","bg","color","from","fg","contains","needsUpdate","draw","force","messageColor","tempColor","make","isOnTop","fillRect","forEach","msg","confirmed","i","copy","mix","localY","toBufferY","text","eachChar","c","_bg","j","toBufferX","async","reverse","fadePercent","fastForward","currentMessageCount","totalMessageCount","dbuf","startDialog","resetDialogBuffer","_confirmed","floor","clone","wrapText","render","loop","pause","waitForAck","finishDialog","confirmAll","layers","freeBuffers","inDialog","canvas","Error","base","push","pop","Buffer","dest","follow","snap","filter","offsetX","offsetY","lockX","lockY","lock","toMapX","toMapY","toInnerX","toInnerY","halfWidth","halfHeight","map","playerX","playerY","undefined","left","right","top","bottom","edgeX","edgeY","thirdW","max","thirdH","clamp","mixer","sprite","Mixer","mapX","mapY","hasXY","getAppearanceAt","blackOut","drawSprite"],"mappings":"ukBACO,MACHA,YAAYC,GACR,MAAMC,EAASD,EAAKE,GAAGD,OACvBE,KAAKC,OAAS,IAAIC,EAAIC,GAAGC,OAAOP,EAAKQ,EAAGR,EAAKS,EAAGC,KAAKC,IAAIX,EAAKY,OAASX,EAAOW,MAAOX,EAAOW,MAAQZ,EAAKQ,GAAIE,KAAKC,IAAIX,EAAKa,QAAUZ,EAAOY,OAAQZ,EAAOY,OAASb,EAAKS,IACzKN,KAAKW,MAAQ,IAAIT,EAAIU,QAAQC,aAAa,CACtCJ,MAAOT,KAAKC,OAAOQ,MACnBK,OAAQhB,EAAOY,SAEnBV,KAAKD,GAAKF,EAAKE,GACfC,KAAKe,GAAKb,EAAIc,MAAMC,KAAKpB,EAAKkB,IAAM,SACpCf,KAAKkB,GAAKhB,EAAIc,MAAMC,KAAKpB,EAAKqB,IAAM,SAExCC,SAASd,EAAGC,GACR,OAAON,KAAKC,OAAOkB,SAASd,EAAGC,GAE/Bc,kBACA,OAAOpB,KAAKW,MAAMS,YAElBtB,aACA,OAAOE,KAAKD,GAAGD,OAEnBuB,KAAKC,GAAQ,GACT,IAAKA,IAAUtB,KAAKW,MAAMS,YACtB,OAAO,EACX,IAAIG,EACJ,MAAMC,EAAYtB,EAAIc,MAAMS,OACtBC,EAAU1B,KAAKC,OAAOK,EAAI,GA6BhC,OA3BAN,KAAKF,OAAO6B,SAAS3B,KAAKC,OAAOI,EAAGL,KAAKC,OAAOK,EAAGN,KAAKC,OAAOQ,MAAOT,KAAKC,OAAOS,OAAQ,IAAK,EAAGV,KAAKe,IACvGf,KAAKW,MAAMiB,SAAQ,CAACC,EAAKC,EAAWC,KAChC,GAAIA,GAAK/B,KAAKC,OAAOS,OACjB,OACJa,EAAeC,EACfD,EAAaS,KAAKhC,KAAKkB,IACnBY,IACAP,EAAaU,IAAIjC,KAAKe,GAAI,IAC1BQ,EAAaU,IAAIjC,KAAKe,GAAK,GAAKgB,GAAM,EAAI/B,KAAKC,OAAOS,UAE1D,MAAMwB,EAASR,EAAU1B,KAAKC,OAAOS,OAASqB,EAAI,EAAIA,EAChDzB,EAAIN,KAAKmC,UAAUD,GACzBhC,EAAIkC,KAAKC,SAASR,GAAK,CAACS,EAAGtB,EAAOuB,EAAKC,KACnC,MAAMnC,EAAIL,KAAKyC,UAAUD,GACrBxB,GAASO,IAAiBP,GAASc,IACnCd,EAAMiB,IAAIjC,KAAKe,GAAI,IACnBC,EAAMiB,IAAIjC,KAAKe,GAAK,GAAKgB,GAAM,EAAI/B,KAAKC,OAAOS,UAEnDa,EAAeP,GAASQ,EACxBxB,KAAKF,OAAOuB,KAAKhB,EAAGC,EAAGgC,EAAGf,EAAcvB,KAAKe,UAOrDf,KAAKW,MAAMS,aAAc,GAClB,EAEXe,UAAU7B,GACN,OAAON,KAAKC,OAAOK,EAAIA,EAE3BmC,UAAUpC,GACN,OAAOL,KAAKC,OAAOI,EAAIA,EAE3BqC,oBACI,IAAIC,EAASC,EACTC,EADsBC,EAAsB,EAG5CC,EAAoB,EAExB,GADA/C,KAAKW,MAAMiB,SAAQ,MAAQmB,IACvBA,GAAqB/C,KAAKC,OAAOS,OACjC,OACJ,MAAMgB,EAAU1B,KAAKC,OAAOK,EAAI,GAC1B0C,EAAOhD,KAAKD,GAAGkD,cAErB,IAAKN,EAAU,EAAGA,GAAW,EAAGA,IAAW,CAEvC,IADAE,GAAc,EACTC,EAAsBH,EACrBI,EACA/C,KAAKC,OAAOS,OAAQiC,EACpBG,GAAuB9C,KAAKC,OAAOS,OACnCoC,GAAuBC,EAAmBD,GAAuBH,GAAW,EAAI,EAClF3C,KAAKD,GAAGmD,kBAAkBF,GAE1BhD,KAAKW,MAAMiB,SAAQ,CAACC,EAAKsB,EAAYX,KACjC,GAAIA,GAAKM,GAAuBN,GAAKQ,EAAKtC,OACtC,OACJ,MAAMJ,EAAIoB,EAAUc,EAAIQ,EAAKtC,OAAS8B,EAAI,EAC1CI,EAAcrC,KAAK6C,MAAO,IAAMN,EAAsBN,GAAMM,GAC5D,MAAM5B,EAAKlB,KAAKkB,GAAGmC,QAAQpB,IAAIjC,KAAKe,GAAI6B,GACxCI,EAAKM,SAAStD,KAAKyC,UAAU,GAAInC,EAAGN,KAAKC,OAAOQ,MAAOoB,EAAKX,EAAIlB,KAAKe,OAEzEiC,EAAKO,UACAV,SACM7C,KAAKD,GAAGyD,KAAKC,MAAMd,EAAU,GAAK,MACzCE,GAAc,EAEdC,EAAsBH,EAChB3C,KAAKC,OAAOS,OAAS,EACrBqC,EAAoB,GAGlC,IAAKJ,EAAS,CACV,MAAMrC,EAAIoB,EAAU,EAAIsB,EAAKtC,OAAS,EAChCL,EAAIL,KAAKC,OAAOI,EAAI,EACpBL,KAAKC,OAAOI,EAAI,EAChBE,KAAKC,IAAIR,KAAKC,OAAOI,EAAIL,KAAKC,OAAOQ,MACvCT,KAAKF,OAAOW,MAAQ,GAExBuC,EAAKM,SAASjD,EAAGC,EAAG,EAAG,WAAYN,KAAKe,GAAIf,KAAKkB,IACjD8B,EAAKO,eACCvD,KAAKD,GAAGyD,KAAKE,cAG3B1D,KAAKD,GAAG4D,eACR3D,KAAKW,MAAMiD,aACX5D,KAAKW,MAAMS,aAAc,SCnH1B,MACHxB,YAAYC,EAAO,IAIf,GAHAG,KAAK6D,OAAS,GACd7D,KAAK8D,YAAc,GACnB9D,KAAK+D,UAAW,GACXlE,EAAKmE,OACN,MAAM,IAAIC,MAAM,kBACpBjE,KAAKgE,OAASnE,EAAKmE,OACnBhE,KAAKF,OAASD,EAAKmE,OAAOlE,OAC1BE,KAAKwD,KAAO3D,EAAK2D,MAAQtD,EAAIsD,KAEjCD,SACIvD,KAAKF,OAAOyD,SAEhBN,cACIjD,KAAK+D,UAAW,EAChB,MAAMG,EAAOlE,KAAKF,QAAUE,KAAKgE,OAAOlE,OAMxC,OALAE,KAAK6D,OAAOM,KAAKD,GACjBlE,KAAKF,OACDE,KAAK8D,YAAYM,OAAS,IAAIlE,EAAI8D,OAAOK,OAAOrE,KAAKgE,QAEzDhE,KAAKF,OAAOkC,KAAKkC,GACVlE,KAAKF,OAEhBoD,kBAAkBoB,GACd,MAAMJ,EAAOlE,KAAK6D,OAAO7D,KAAK6D,OAAO/C,OAAS,IAAMd,KAAKgE,OAAOlE,OAChEwE,EAAKtC,KAAKkC,GAEdP,eACS3D,KAAK+D,WAEN/D,KAAKF,SAAWE,KAAKgE,OAAOlE,QAC5BE,KAAK8D,YAAYK,KAAKnE,KAAKF,QAE/BE,KAAKF,OAASE,KAAK6D,OAAOO,OAASpE,KAAKgE,OAAOlE,OAC/CE,KAAKF,OAAOyD,SACZvD,KAAK+D,SAAW/D,KAAK6D,OAAO/C,OAAS,gBCpCtC,MACHlB,YAAYC,GACRG,KAAKuE,QAAS,EACdvE,KAAKwE,MAAO,EACZxE,KAAKyE,OAAS,KACdzE,KAAK0E,QAAU,EACf1E,KAAK2E,QAAU,EACf3E,KAAK4E,OAAQ,EACb5E,KAAK6E,OAAQ,EACb7E,KAAKD,GAAKF,EAAKE,GACfC,KAAKuE,OAAS1E,EAAK0E,SAAU,EAC7BvE,KAAKwE,KAAO3E,EAAK2E,OAAQ,EACzBxE,KAAKC,OAAS,IAAIC,EAAIC,GAAGC,OAAOP,EAAKQ,EAAGR,EAAKS,EAAGT,EAAKY,MAAOZ,EAAKa,QACjEV,KAAKyE,OAAS5E,EAAK4E,QAAU,KACzB5E,EAAKiF,MACL9E,KAAK4E,OAAQ,EACb5E,KAAK6E,OAAQ,IAGThF,EAAK+E,QACL5E,KAAK4E,OAAQ,GAEb/E,EAAKgF,QACL7E,KAAK6E,OAAQ,IAIzBE,OAAO1E,GACH,OAAOA,EAAIL,KAAK0E,QAEpBM,OAAO1E,GACH,OAAOA,EAAIN,KAAK2E,QAEpBM,SAAS5E,GACL,OAAOA,EAAIL,KAAKC,OAAOI,EAE3B6E,SAAS5E,GACL,OAAOA,EAAIN,KAAKC,OAAOK,EAE3Ba,SAASd,EAAGC,GACR,OAAON,KAAKC,OAAOkB,SAASd,EAAGC,GAEnC6E,YACI,OAAO5E,KAAK6C,MAAMpD,KAAKC,OAAOQ,MAAQ,GAE1C2E,aACI,OAAO7E,KAAK6C,MAAMpD,KAAKC,OAAOS,OAAS,GAE3CW,KAAKgE,EAAKC,EAASC,GACf,IAAKF,EACD,OAAO,EAEX,GAAIrF,KAAKuE,aAAsBiB,IAAZF,QAAqCE,IAAZD,EACxCvF,KAAK0E,QAAUY,EAAUtF,KAAKmF,YAC9BnF,KAAK2E,QAAUY,EAAUvF,KAAKoF,kBAE7B,GAAIpF,KAAKwE,WACEgB,IAAZF,QACYE,IAAZD,EAAuB,CACvB,MAAME,EAAOzF,KAAK0E,QACZgB,EAAQ1F,KAAK0E,QAAU1E,KAAKC,OAAOQ,MACnCkF,EAAM3F,KAAK2E,QACXiB,EAAS5F,KAAK2E,QAAU3E,KAAKC,OAAOS,OACpCmF,EAAQtF,KAAK6C,MAAMpD,KAAKC,OAAOQ,MAAQ,GACvCqF,EAAQvF,KAAK6C,MAAMpD,KAAKC,OAAOS,OAAS,GACxCqF,EAASxF,KAAK6C,MAAMpD,KAAKC,OAAOQ,MAAQ,GAC1CgF,EAAOI,GAASP,EAChBtF,KAAK0E,QAAUnE,KAAKyF,IAAI,EAAGV,EAAUS,EAAS/F,KAAKC,OAAOQ,OAErDiF,EAAQG,GAASP,IACtBtF,KAAK0E,QAAUnE,KAAKC,IAAI8E,EAAUS,EAAQV,EAAI5E,MAAQT,KAAKC,OAAOQ,QAEtE,MAAMwF,EAAS1F,KAAK6C,MAAMpD,KAAKC,OAAOS,OAAS,GAC3CiF,EAAMG,GAASP,EACfvF,KAAK2E,QAAUpE,KAAKyF,IAAI,EAAGT,EAAUU,EAASjG,KAAKC,OAAOS,QAErDkF,EAASE,GAASP,IACvBvF,KAAK2E,QAAUpE,KAAKC,IAAI+E,EAAUU,EAAQZ,EAAI3E,OAASV,KAAKC,OAAOS,mBAGtD8E,IAAZF,QAAqCE,IAAZD,IAC9BvF,KAAK0E,QAAUY,EACftF,KAAK2E,QAAUY,GAEfvF,KAAK4E,QACL5E,KAAK0E,QAAUxE,EAAIgG,MAAMlG,KAAK0E,QAAS,EAAGW,EAAI5E,MAAQT,KAAKC,OAAOQ,QAElET,KAAK6E,QACL7E,KAAK2E,QAAUzE,EAAIgG,MAAMlG,KAAK2E,QAAS,EAAGU,EAAI3E,OAASV,KAAKC,OAAOS,SAEvE,MAAMyF,EAAQ,IAAIjG,EAAIkG,OAAOC,MAC7B,IAAK,IAAIhG,EAAI,EAAGA,EAAIL,KAAKC,OAAOQ,QAASJ,EACrC,IAAK,IAAIC,EAAI,EAAGA,EAAIN,KAAKC,OAAOS,SAAUJ,EAAG,CACzC,MAAMgG,EAAOjG,EAAIL,KAAK0E,QAChB6B,EAAOjG,EAAIN,KAAK2E,QAClBU,EAAImB,MAAMF,EAAMC,GAChBlB,EAAIoB,gBAAgBH,EAAMC,EAAMJ,GAGhCA,EAAMO,WAEN1G,KAAKyE,QACLzE,KAAKyE,OAAO0B,EAAOG,EAAMC,EAAMlB,GAEnCrF,KAAKD,GAAGD,OAAO6G,WAAWtG,EAAIL,KAAKC,OAAOI,EAAGC,EAAIN,KAAKC,OAAOK,EAAG6F,GAIxE,OAAO"}